<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Live Crash Analytics Dashboard - BigQuery Connected</title>
	<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50' font-size='48'%3E%F0%9F%9A%A8%3C/text%3E%3C/svg%3E">
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			min-height: 100vh;
			padding: 20px;
		}

		.dashboard {
			max-width: 1400px;
			margin: 0 auto;
		}

		.header {
			background: rgba(255, 255, 255, 0.95);
			border-radius: 15px;
			padding: 25px;
			margin-bottom: 25px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.header-content h1 {
			color: #2d3748;
			font-size: 32px;
			margin-bottom: 10px;
		}

		.header-content .subtitle {
			color: #718096;
			font-size: 14px;
		}

		.header-actions {
			display: flex;
			gap: 15px;
			align-items: center;
		}

		.status {
			padding: 8px 16px;
			border-radius: 20px;
			font-size: 12px;
			font-weight: 600;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.status.connected {
			background: #c6f6d5;
			color: #22543d;
		}

		.status.disconnected {
			background: #fed7d7;
			color: #c53030;
		}

		.status.loading {
			background: #fef5e7;
			color: #d68910;
		}

		.status-dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: currentColor;
			animation: pulse 2s infinite;
		}

		@keyframes pulse {
			0% { opacity: 1; }
			50% { opacity: 0.5; }
			100% { opacity: 1; }
		}

		.btn-primary {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			border: none;
			padding: 12px 24px;
			border-radius: 8px;
			font-weight: 600;
			cursor: pointer;
			transition: transform 0.2s ease, box-shadow 0.2s ease;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.btn-primary:hover:not(:disabled) {
			transform: translateY(-2px);
			box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
		}

		.btn-primary:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}

		.btn-secondary {
			background: white;
			color: #667eea;
			border: 2px solid #667eea;
			padding: 10px 20px;
			border-radius: 8px;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.btn-secondary:hover {
			background: #667eea;
			color: white;
		}

		input[type="text"] {
			padding: 8px 12px;
			border: 2px solid #e2e8f0;
			border-radius: 8px;
			font-size: 14px;
			background: white;
			transition: all 0.3s ease;
		}

		input[type="text"]:hover { border-color: #667eea; }
		input[type="text"]:focus { outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }

		.auth-modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			z-index: 1000;
			align-items: center;
			justify-content: center;
		}

		.auth-modal.show {
			display: flex;
		}

		.auth-content {
			background: white;
			border-radius: 15px;
			padding: 30px;
			max-width: 400px;
			width: 90%;
			text-align: center;
		}

		.auth-content h2 {
			margin-bottom: 20px;
			color: #2d3748;
		}

		.auth-content p {
			color: #718096;
			margin-bottom: 25px;
		}

		.controls {
			background: rgba(255, 255, 255, 0.95);
			border-radius: 15px;
			padding: 20px;
			margin-bottom: 25px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
		}

		.controls-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
		}

		.controls-header h3 {
			color: #2d3748;
			font-size: 18px;
		}

		.auto-refresh {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.auto-refresh label {
			font-size: 14px;
			color: #4a5568;
		}

		.switch {
			position: relative;
			display: inline-block;
			width: 50px;
			height: 24px;
		}

		.switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #cbd5e0;
			transition: .4s;
			border-radius: 24px;
		}

		.slider:before {
			position: absolute;
			content: "";
			height: 18px;
			width: 18px;
			left: 3px;
			bottom: 3px;
			background-color: white;
			transition: .4s;
			border-radius: 50%;
		}

		input:checked + .slider {
			background-color: #667eea;
		}

		input:checked + .slider:before {
			transform: translateX(26px);
		}

		.filters {
			display: flex;
			gap: 20px;
			flex-wrap: wrap;
		}

		.filter-group {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.filter-group label {
			font-size: 12px;
			color: #4a5568;
			font-weight: 600;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		.multi-select {
			position: relative;
			display: inline-block;
			width: 100%;
		}

		.multi-select-dropdown {
			padding: 8px 12px;
			border: 2px solid #e2e8f0;
			border-radius: 8px;
			font-size: 14px;
			background: white;
			cursor: pointer;
			display: flex;
			justify-content: space-between;
			align-items: center;
			min-height: 40px;
			transition: all 0.3s ease;
		}

		.multi-select-dropdown:hover {
			border-color: #667eea;
		}

		.multi-select-dropdown.open {
			border-color: #667eea;
			box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
		}

		.multi-select-options {
			position: absolute;
			top: 100%;
			left: 0;
			right: 0;
			background: white;
			border: 2px solid #667eea;
			border-radius: 8px;
			margin-top: 2px;
			max-height: 200px;
			overflow-y: auto;
			z-index: 1000;
			display: none;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
		}

		.multi-select-options.show {
			display: block;
		}

		.multi-select-option {
			padding: 8px 12px;
			display: flex;
			align-items: center;
			gap: 8px;
			cursor: pointer;
			transition: background-color 0.2s ease;
		}

		.multi-select-option:hover {
			background-color: #f7fafc;
		}

		.multi-select-option input[type="checkbox"] {
			margin: 0;
		}

		.multi-select-placeholder {
			color: #718096;
			font-style: italic;
		}

		.multi-select-selected {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
		}

		.multi-select-tag {
			background: #667eea;
			color: white;
			padding: 2px 6px;
			border-radius: 4px;
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 4px;
		}

		.multi-select-tag .remove {
			cursor: pointer;
			font-weight: bold;
		}

		.multi-select-actions {
			display: flex;
			gap: 8px;
			padding: 8px 12px;
			border-bottom: 1px solid #e2e8f0;
			background: #f7fafc;
		}

		.multi-select-actions button {
			background: #667eea;
			color: white;
			border: none;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 11px;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		.multi-select-actions button:hover {
			background: #5a67d8;
		}

		.multi-select-actions .clear-btn {
			background: #ef4444;
		}

		.multi-select-actions .clear-btn:hover {
			background: #dc2626;
		}

		.date-range-container {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.date-range-type {
			display: flex;
			gap: 10px;
			align-items: center;
		}

		.date-range-type input[type="radio"] {
			margin: 0;
		}

		.hours-input-container {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.hours-input-container input[type="number"] {
			width: 60px;
			padding: 4px 8px;
			border: 2px solid #e2e8f0;
			border-radius: 4px;
			font-size: 12px;
		}

		.absolute-date-container {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.absolute-date-inputs {
			display: flex;
			gap: 5px;
			align-items: center;
		}

		.absolute-date-inputs input[type="date"] {
			padding: 6px 8px;
			border: 2px solid #e2e8f0;
			border-radius: 4px;
			font-size: 12px;
		}

		.search-button-container {
			display: flex;
			justify-content: center;
			margin-top: 20px;
			padding-top: 20px;
			border-top: 1px solid #e2e8f0;
		}

		.btn-search {
			background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
			color: white;
			border: none;
			padding: 12px 32px;
			border-radius: 8px;
			font-weight: 600;
			font-size: 16px;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			align-items: center;
			gap: 8px;
			box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
		}

		.btn-search:hover:not(:disabled) {
			transform: translateY(-2px);
			box-shadow: 0 4px 16px rgba(34, 197, 94, 0.4);
		}

		.btn-search:disabled {
			opacity: 0.6;
			cursor: not-allowed;
			transform: none;
		}

		.no-results-modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			z-index: 1000;
			align-items: center;
			justify-content: center;
		}

		.no-results-modal.show {
			display: flex;
		}

		.no-results-content {
			background: white;
			border-radius: 15px;
			padding: 30px;
			max-width: 400px;
			width: 90%;
			text-align: center;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
		}

		.no-results-content .icon {
			font-size: 48px;
			margin-bottom: 15px;
		}

		.no-results-content h2 {
			margin-bottom: 15px;
			color: #2d3748;
			font-size: 24px;
		}

		.no-results-content p {
			color: #718096;
			margin-bottom: 25px;
			line-height: 1.6;
		}

		.no-results-content .suggestions {
			background: #f7fafc;
			border-radius: 8px;
			padding: 15px;
			margin-bottom: 20px;
			text-align: left;
		}

		.no-results-content .suggestions h4 {
			color: #4a5568;
			margin-bottom: 8px;
			font-size: 14px;
		}

		.no-results-content .suggestions ul {
			color: #718096;
			font-size: 13px;
			margin-left: 15px;
		}

		.no-results-content .suggestions li {
			margin-bottom: 4px;
		}

		select, input[type="date"] {
			padding: 8px 12px;
			border: 2px solid #e2e8f0;
			border-radius: 8px;
			font-size: 14px;
			background: white;
			transition: all 0.3s ease;
		}

		select:hover, input[type="date"]:hover {
			border-color: #667eea;
		}

		select:focus, input[type="date"]:focus {
			outline: none;
			border-color: #667eea;
			box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
		}

		.metrics {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
			gap: 20px;
			margin-bottom: 25px;
		}

		.metric-card {
			background: rgba(255, 255, 255, 0.95);
			border-radius: 15px;
			padding: 25px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
			transition: transform 0.3s ease;
			position: relative;
			overflow: hidden;
		}

		.metric-card:hover {
			transform: translateY(-5px);
		}

		.metric-card.loading::after {
			content: '';
			position: absolute;
			top: 0;
			left: -100%;
			width: 100%;
			height: 100%;
			background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
			animation: shimmer 2s infinite;
		}

		@keyframes shimmer {
			100% { left: 100%; }
		}

		.metric-label {
			color: #718096;
			font-size: 12px;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			margin-bottom: 8px;
		}

		.metric-value {
			font-size: 36px;
			font-weight: bold;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
		}

		.metric-change {
			font-size: 12px;
			margin-top: 8px;
		}

		.metric-subtitle {
			font-size: 11px;
			color: #718096;
			margin-top: 2px;
			font-style: italic;
		}

		.metric-change.positive {
			color: #48bb78;
		}

		.metric-change.negative {
			color: #f56565;
		}

		.charts {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
			gap: 20px;
			margin-bottom: 25px;
		}

		.chart-container {
			background: rgba(255, 255, 255, 0.95);
			border-radius: 15px;
			padding: 25px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
			margin-bottom: 25px;
		}

		.chart-container h3 {
			color: #2d3748;
			margin-bottom: 20px;
			font-size: 18px;
		}

		.chart-container.full-width {
			grid-column: 1 / -1;
		}

		.table-container {
			background: rgba(255, 255, 255, 0.95);
			border-radius: 15px;
			padding: 25px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
			overflow-x: auto;
		}

		.table-container h3 {
			color: #2d3748;
			margin-bottom: 20px;
			font-size: 18px;
		}

		table {
			width: 100%;
			border-collapse: collapse;
		}

		th {
			background: #f7fafc;
			padding: 12px;
			text-align: left;
			font-size: 12px;
			color: #4a5568;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			border-bottom: 2px solid #e2e8f0;
		}

		td {
			padding: 12px;
			border-bottom: 1px solid #e2e8f0;
			font-size: 14px;
			color: #2d3748;
		}

		tr:hover {
			background: #f7fafc;
		}

		.platform-badge {
			display: inline-block;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 12px;
			font-weight: 600;
		}

		.platform-ios {
			background: #000;
			color: #fff;
		}

		.platform-android {
			background: #3ddc84;
			color: #fff;
		}

		.risk-badge {
			display: inline-block;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 12px;
			font-weight: 600;
		}

		.risk-critical {
			background: #fed7d7;
			color: #c53030;
		}

		.risk-high {
			background: #feebc8;
			color: #c05621;
		}

		.risk-medium {
			background: #fef5e7;
			color: #d68910;
		}

		.risk-low {
			background: #c6f6d5;
			color: #22543d;
		}

		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.7);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 999;
		}

		.loading-overlay.show {
			display: flex;
		}

		.loading-content {
			background: white;
			border-radius: 15px;
			padding: 30px;
			text-align: center;
		}

		.spinner {
			border: 3px solid #f3f4f6;
			border-top: 3px solid #667eea;
			border-radius: 50%;
			width: 50px;
			height: 50px;
			animation: spin 1s linear infinite;
			margin: 20px auto;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		.last-updated {
			font-size: 12px;
			color: #718096;
			margin-top: 10px;
		}

		canvas {
			max-height: 400px;
		}

		/* Table sorting styles */
		th[data-sort] {
			cursor: pointer;
			position: relative;
		}

		th[data-sort]:hover {
			background-color: #edf2f7;
		}

		.sort-indicator {
			opacity: 0.3;
			margin-left: 4px;
		}

		th[data-sort]:hover .sort-indicator {
			opacity: 0.6;
		}

		th.sort-asc .sort-indicator,
		th.sort-desc .sort-indicator {
			opacity: 1;
		}

		th.sort-asc .sort-indicator {
			content: '‚Üë';
		}

		th.sort-desc .sort-indicator {
			content: '‚Üì';
		}
	</style>
</head>
<body>
	<div class="dashboard">
		<div class="header">
			<div class="header-content">
				<h1>üö® Live Crash Analytics Dashboard</h1>
				<div class="subtitle">BigQuery Connected - Real-time crash monitoring</div>
				<div class="last-updated" id="lastUpdated">Last updated: Never</div>
			</div>
			<div class="header-actions">
				<div class="status disconnected" id="connectionStatus">
					<span class="status-dot"></span>
					<span>Disconnected</span>
				</div>
				<button class="btn-secondary" id="authBtn" onclick="authenticate()">
					üîê Connect to BigQuery
				</button>
				<button class="btn-primary" id="refreshBtn" onclick="refreshData()" disabled>
					üîÑ Refresh Data
				</button>
				<button class="btn-secondary" id="settingsBtn" onclick="openSettings()">
					‚öôÔ∏è Settings
				</button>
			</div>
		</div>

		<div class="controls">
			<div class="controls-header">
				<h3>Filters & Settings</h3>
				<div class="auto-refresh">
					<label for="autoRefresh">Auto-refresh every 5 min</label>
					<label class="switch">
						<input type="checkbox" id="autoRefresh">
						<span class="slider"></span>
					</label>
				</div>
			</div>

			<div class="filters">
				<div class="filter-group">
					<label>Date Range</label>
					<div class="date-range-container">
						<div class="date-range-type">
							<input type="radio" id="relativeDateType" name="dateRangeType" value="relative" checked>
							<label for="relativeDateType" style="text-transform: none; font-size: 14px;">Relative</label>
							<input type="radio" id="absoluteDateType" name="dateRangeType" value="absolute">
							<label for="absoluteDateType" style="text-transform: none; font-size: 14px;">Absolute</label>
						</div>
						
						<div id="relativeDateContainer">
							<select id="dateRange">
								<option value="hour">Last hour</option>
								<option value="1">Last 24 hours</option>
								<option value="3">Last 3 days</option>
								<option value="7">Last 7 days</option>
								<option value="14">Last 14 days</option>
								<option value="30">Last 30 days</option>
								<option value="custom_hours">Custom hours</option>
							</select>
							<div id="hoursInputContainer" class="hours-input-container" style="display: none;">
								<span>Last</span>
								<input type="number" id="customHours" min="1" max="168" value="12" placeholder="12">
								<span>hours</span>
							</div>
						</div>
						
						<div id="absoluteDateContainer" class="absolute-date-container" style="display: none;">
							<div class="absolute-date-inputs">
								<input type="date" id="dateFrom" title="Start Date">
								<span>to</span>
								<input type="date" id="dateTo" title="End Date">
							</div>
						</div>
					</div>
				</div>

				<div class="filter-group">
					<label>Platform</label>
					<select id="platformFilter">
						<option value="">All Platforms</option>
						<option value="IOS">iOS</option>
						<option value="ANDROID">Android</option>
					</select>
				</div>

				<div class="filter-group">
					<label>Risk Level</label>
					<select id="riskFilter">
						<option value="">All Risk Levels</option>
						<option value="90">Critical (90+)</option>
						<option value="75">High (75+)</option>
						<option value="50">Medium (50+)</option>
					</select>
				</div>

				<div class="filter-group">
					<label>Data Source</label>
					<select id="sourceFilter">
						<option value="">All Sources</option>
						<option value="Both">Both Systems</option>
						<option value="Crashlytics Only">Crashlytics Only</option>
						<option value="Sentry Only">Sentry Only</option>
					</select>
				</div>

				<div class="filter-group">
					<label>Event Type</label>
					<select id="crashTypeFilter">
						<option value="">All Events</option>
						<option value="fatal">Crashes Only</option>
						<option value="non-fatal">Errors Only</option>
					</select>
				</div>

				<div class="filter-group">
					<label>Memory Range</label>
					<div class="multi-select" id="memoryMultiSelect">
						<div class="multi-select-dropdown" id="memoryDropdown">
							<div class="multi-select-placeholder">Select Memory Levels</div>
							<span>‚ñº</span>
						</div>
						<div class="multi-select-options" id="memoryOptions">
							<div class="multi-select-actions">
								<button onclick="selectAllOptions('memoryOptions')" title="Select All">Select All</button>
								<button onclick="clearAllOptions('memoryOptions')" class="clear-btn" title="Clear All">Clear All</button>
							</div>
							<div class="multi-select-option">
								<input type="checkbox" id="mem_critical" value="critical">
								<label for="mem_critical">Critical (<50MB)</label>
							</div>
							<div class="multi-select-option">
								<input type="checkbox" id="mem_low" value="low">
								<label for="mem_low">Low (50-100MB)</label>
							</div>
							<div class="multi-select-option">
								<input type="checkbox" id="mem_medium" value="medium">
								<label for="mem_medium">Medium (100-200MB)</label>
							</div>
							<div class="multi-select-option">
								<input type="checkbox" id="mem_good" value="good">
								<label for="mem_good">Good (200-500MB)</label>
							</div>
							<div class="multi-select-option">
								<input type="checkbox" id="mem_excellent" value="excellent">
								<label for="mem_excellent">Excellent (>500MB)</label>
							</div>
						</div>
					</div>
				</div>

				<div class="filter-group">
					<label>App Version</label>
					<div class="multi-select" id="appVersionMultiSelect">
						<div class="multi-select-dropdown" id="appVersionDropdown">
							<div class="multi-select-placeholder">Select App Versions</div>
							<span>‚ñº</span>
						</div>
						<div class="multi-select-options" id="appVersionOptions">
							<div class="multi-select-actions">
								<button onclick="selectAllOptions('appVersionOptions')" title="Select All">Select All</button>
								<button onclick="clearAllOptions('appVersionOptions')" class="clear-btn" title="Clear All">Clear All</button>
							</div>
							<!-- Options will be populated dynamically -->
						</div>
					</div>
				</div>
			</div>

			<div class="search-button-container">
				<button class="btn-search" id="searchButton" onclick="executeSearch()" disabled>
					üîç Search Results
				</button>
			</div>
		</div>

		<div class="metrics">
			<div class="metric-card loading">
				<div class="metric-label">Total Events</div>
				<div class="metric-value" id="totalCrashes">-</div>
				<div class="metric-change" id="crashChange">Loading...</div>
				<div class="metric-subtitle" id="eventsPerUser">-</div>
			</div>

			<div class="metric-card loading">
				<div class="metric-label">Affected Users</div>
				<div class="metric-value" id="affectedUsers">-</div>
				<div class="metric-change" id="userChange">Loading...</div>
				<div class="metric-subtitle" id="usersSubtitle">users experienced events</div>
			</div>

			<div class="metric-card loading">
				<div class="metric-label">Crashes</div>
				<div class="metric-value" id="fatalCrashes">-</div>
				<div class="metric-change" id="fatalChange">Loading...</div>
			</div>

			<div class="metric-card loading">
				<div class="metric-label">Errors</div>
				<div class="metric-value" id="nonFatalCrashes">-</div>
				<div class="metric-change" id="nonFatalChange">Loading...</div>
			</div>

			<div class="metric-card loading">
				<div class="metric-label">Avg Risk Score</div>
				<div class="metric-value" id="avgRiskScore">-</div>
				<div class="metric-change" id="riskChange">Loading...</div>
			</div>

			<div class="metric-card loading">
				<div class="metric-label">Top App Version</div>
				<div class="metric-value" id="topAppVersion">-</div>
				<div class="metric-subtitle" id="appVersionSubtitle">most affected version</div>
			</div>
		</div>

		<div class="charts">
			<div class="chart-container">
				<h3>Platform Distribution</h3>
				<canvas id="platformChart"></canvas>
			</div>

			<div class="chart-container">
				<h3>Top 10 Crashing Devices</h3>
				<canvas id="deviceChart"></canvas>
			</div>

			<div class="chart-container full-width">
				<h3>Error Events Trend</h3>
				<canvas id="crashTrendChart"></canvas>
			</div>

			<div class="chart-container">
				<h3>Error Type Distribution</h3>
				<canvas id="errorChart"></canvas>
			</div>

			<div class="chart-container">
				<h3>Crashes vs Errors</h3>
				<canvas id="fatalityChart"></canvas>
			</div>

			<div class="chart-container">
				<h3>Top App Versions</h3>
				<canvas id="appVersionChart"></canvas>
			</div>

			<div class="chart-container">
				<h3 id="memoryChartTitle">Memory vs Events</h3>
				<canvas id="memoryChart"></canvas>
			</div>

			<div class="chart-container">
				<h3>Top Crash Names</h3>
				<canvas id="crashNamesChart"></canvas>
			</div>
		</div>

		<div class="table-container">
			<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
				<h3>High Risk Users (Risk Score ‚â• 75)</h3>
				<button id="exportCsv" class="btn-secondary" onclick="exportTableToCsv()" disabled>
					üìä Export to CSV
				</button>
			</div>
			<div id="tableLoading" class="loading">
				<div class="spinner"></div>
				Loading user data...
			</div>
			<table id="userTable" style="display: none;">
				<thead>
					<tr>
						<th data-sort="user_id">User ID <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="platform">Platform <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="device_model">Device <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="app_version">App Version <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="errors">Total Errors <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="risk">Risk Score <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="last_24h">Last 24h <span class="sort-indicator">‚Üï</span></th>
						<th data-sort="source">Data Source <span class="sort-indicator">‚Üï</span></th>
						<th>Crashlytics Details</th>
						<th>Sentry Details</th>
						<th>Error Stats</th>
						<th data-sort="last_seen">Last Seen <span class="sort-indicator">‚Üï</span></th>
					</tr>
				</thead>
				<tbody id="userTableBody">
				</tbody>
			</table>
		</div>
	</div>

	<!-- Auth Modal -->
	<div class="auth-modal" id="authModal">
		<div class="auth-content">
			<h2>Connect to BigQuery</h2>
			<p>Click below to authenticate with Google and connect to your BigQuery project</p>
			<button class="btn-primary" onclick="signIn()">
				üîó Connect with Google
			</button>
		</div>
	</div>

	<!-- Settings Modal -->
	<div class="auth-modal" id="settingsModal">
		<div class="auth-content">
			<h2>Settings</h2>
			<p>Paste your OAuth Client ID and optional API Key. Saved to this browser only.</p>
			<div style="display:flex;flex-direction:column;gap:10px;text-align:left;margin-top:10px;">
				<label>Client ID
					<input type="text" id="cfgClientId" placeholder="YOUR_CLIENT_ID.apps.googleusercontent.com" />
				</label>
				<label>API Key (optional)
					<input type="text" id="cfgApiKey" placeholder="YOUR_API_KEY" />
				</label>
			</div>
			<div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
				<button class="btn-primary" onclick="saveSettings()">üíæ Save</button>
				<button class="btn-secondary" onclick="closeSettings()">Cancel</button>
			</div>
		</div>
	</div>

	<!-- Loading Overlay -->
	<div class="loading-overlay" id="loadingOverlay">
		<div class="loading-content">
			<h3>Loading Dashboard Data...</h3>
			<div class="spinner"></div>
			<p id="loadingMessage">Connecting to BigQuery...</p>
		</div>
	</div>

	<!-- No Results Modal -->
	<div class="no-results-modal" id="noResultsModal">
		<div class="no-results-content">
			<div class="icon">üîç</div>
			<h2>No Results Found</h2>
			<p>Your search didn't return any data. This could be due to your filter criteria or the selected date range.</p>
			
			<div class="suggestions">
				<h4>Try adjusting your filters:</h4>
				<ul>
					<li>Expand your date range</li>
					<li>Remove some filter selections</li>
					<li>Try different platforms or risk levels</li>
					<li>Clear memory or app version filters</li>
				</ul>
			</div>

			<div style="display: flex; gap: 10px; justify-content: center;">
				<button class="btn-primary" onclick="closeNoResultsModal()">
					‚úì Got it
				</button>
				<button class="btn-secondary" onclick="clearAllFiltersAndSearch()">
					üîÑ Clear Filters & Search
				</button>
			</div>
		</div>
	</div>

	<script>
		// Configuration
		const CONFIG = {
			CLIENT_ID: '57935720907-du91l7v9gj0i4nbpl3otal7f2ti88c8m.apps.googleusercontent.com',
			API_KEY: 'AIzaSyCXhemEKZQzP3_jhkB9Stc81-zmR-Bdxus',
			DISCOVERY_DOCS: ['https://www.googleapis.com/discovery/v1/apis/bigquery/v2/rest'],
			SCOPES: 'https://www.googleapis.com/auth/bigquery.readonly',
			PROJECT_ID: 'yotam-395120',
			DATASET_ID: 'peerplay'
		};

		let isAuthenticated = false;
		let autoRefreshInterval = null;
		let charts = {};
		let tokenClient = null;
		let accessToken = null;
		let gapiInited = false;
		let gisInited = false;
		let availableAppVersions = [];

		function loadConfigFromStorage() {
			const savedClientId = localStorage.getItem('bq_client_id');
			const savedApiKey = localStorage.getItem('bq_api_key');
			const savedToken = localStorage.getItem('bq_access_token');
			
			if (savedClientId) CONFIG.CLIENT_ID = savedClientId;
			if (savedApiKey) CONFIG.API_KEY = savedApiKey;
			
			// Just store the token, we'll validate it after GAPI is loaded
			if (savedToken) {
				accessToken = savedToken;
				isAuthenticated = true;
			}
		}

		// Call after GAPI is initialized
		async function restoreSession() {
			if (!gapiInited || !gisInited) {
				console.log('Waiting for APIs to initialize...');
				return;
			}

			if (accessToken) {
				try {
					gapi.client.setToken({ access_token: accessToken });
					
					// Verify token is still valid
					await gapi.client.bigquery.projects.list();
					
					// Update UI to show connected state
					document.getElementById('connectionStatus').className = 'status connected';
					document.getElementById('connectionStatus').innerHTML = '<span class="status-dot"></span><span>Connected</span>';
					document.getElementById('authBtn').textContent = '‚úì Connected';
					document.getElementById('refreshBtn').disabled = false;
					
					// Initialize filter components and enable search
					initializeFilterComponents();
					await loadAvailableAppVersions();
					updateSearchButtonState();
					refreshData(); // Initial load
				} catch (e) {
					console.log('Stored token expired, need to re-authenticate');
					localStorage.removeItem('bq_access_token');
					accessToken = null;
					isAuthenticated = false;
					document.getElementById('authModal').classList.add('show');
				}
			}
		}

		// Initialize configuration
		loadConfigFromStorage();

		function validateConfig() {
			if (CONFIG.CLIENT_ID === 'YOUR_CLIENT_ID.apps.googleusercontent.com') {
				alert('Please configure CLIENT_ID in Settings (gear icon) or config.local.json.');
				openSettings();
				return false;
			}
			return true;
		}

		// Configuration is now hardcoded

		// Multi-select dropdown functionality
		function initializeMultiSelect(containerId, optionsId, dropdownId) {
			const container = document.getElementById(containerId);
			const dropdown = document.getElementById(dropdownId);
			const options = document.getElementById(optionsId);
			
			if (!container || !dropdown || !options) return;

			// Toggle dropdown
			dropdown.addEventListener('click', (e) => {
				e.stopPropagation();
				const isOpen = options.classList.contains('show');
				
				// Close all other dropdowns
				document.querySelectorAll('.multi-select-options').forEach(opt => {
					opt.classList.remove('show');
				});
				document.querySelectorAll('.multi-select-dropdown').forEach(dd => {
					dd.classList.remove('open');
				});
				
				// Toggle current dropdown
				if (!isOpen) {
					options.classList.add('show');
					dropdown.classList.add('open');
				}
			});

			// Handle option selection (no automatic refresh)
			options.addEventListener('change', (e) => {
				if (e.target.type === 'checkbox') {
					updateMultiSelectDisplay(containerId, optionsId, dropdownId);
				}
			});

			// Close dropdown when clicking outside
			document.addEventListener('click', (e) => {
				if (!container.contains(e.target)) {
					options.classList.remove('show');
					dropdown.classList.remove('open');
				}
			});
		}

		function updateMultiSelectDisplay(containerId, optionsId, dropdownId) {
			const dropdown = document.getElementById(dropdownId);
			const options = document.getElementById(optionsId);
			const checkboxes = options.querySelectorAll('input[type="checkbox"]:checked');
			
			const displayDiv = dropdown.querySelector('.multi-select-placeholder, .multi-select-selected') || 
								dropdown.querySelector('div:first-child');
			
			if (checkboxes.length === 0) {
				displayDiv.className = 'multi-select-placeholder';
				displayDiv.innerHTML = containerId.includes('memory') ? 'Select Memory Levels' : 'Select App Versions';
			} else {
				displayDiv.className = 'multi-select-selected';
				const tags = Array.from(checkboxes).map(cb => {
					const label = cb.nextElementSibling?.textContent || cb.value;
					return `<span class="multi-select-tag">${label} <span class="remove" onclick="toggleMultiSelectOption('${cb.id}')">&times;</span></span>`;
				}).join('');
				displayDiv.innerHTML = tags;
			}
		}

		function toggleMultiSelectOption(checkboxId) {
			const checkbox = document.getElementById(checkboxId);
			if (checkbox) {
				checkbox.checked = !checkbox.checked;
				const containerId = checkbox.closest('.multi-select').id;
				const optionsId = checkbox.closest('.multi-select-options').id;
				const dropdownId = checkbox.closest('.multi-select').querySelector('.multi-select-dropdown').id;
				updateMultiSelectDisplay(containerId, optionsId, dropdownId);
				// No automatic refresh - user must click Search button
			}
		}

		function getMultiSelectValues(optionsId) {
			const options = document.getElementById(optionsId);
			const checkboxes = options.querySelectorAll('input[type="checkbox"]:checked');
			return Array.from(checkboxes).map(cb => cb.value);
		}

		// Date range type switching
		function initializeDateRangeControls() {
			const relativeDateType = document.getElementById('relativeDateType');
			const absoluteDateType = document.getElementById('absoluteDateType');
			const relativeDateContainer = document.getElementById('relativeDateContainer');
			const absoluteDateContainer = document.getElementById('absoluteDateContainer');
			const dateRange = document.getElementById('dateRange');
			const hoursInputContainer = document.getElementById('hoursInputContainer');
			const customHours = document.getElementById('customHours');
			const dateFrom = document.getElementById('dateFrom');
			const dateTo = document.getElementById('dateTo');

			// Set default dates for absolute range (last 7 days)
			const now = new Date();
			const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
			dateFrom.value = weekAgo.toISOString().slice(0, 10); // YYYY-MM-DD format for date input
			dateTo.value = now.toISOString().slice(0, 10);

			// Toggle between relative and absolute date inputs
			function toggleDateRangeType() {
				if (relativeDateType.checked) {
					relativeDateContainer.style.display = 'block';
					absoluteDateContainer.style.display = 'none';
				} else {
					relativeDateContainer.style.display = 'none';
					absoluteDateContainer.style.display = 'block';
				}
				// No automatic refresh - user must click Search button
			}

			// Show/hide custom hours input
			function toggleCustomHours() {
				if (dateRange.value === 'custom_hours') {
					hoursInputContainer.style.display = 'flex';
				} else {
					hoursInputContainer.style.display = 'none';
				}
			}

			relativeDateType.addEventListener('change', toggleDateRangeType);
			absoluteDateType.addEventListener('change', toggleDateRangeType);
			dateRange.addEventListener('change', toggleCustomHours);
			// No automatic refresh listeners - user must click Search button

			// Initialize visibility
			toggleDateRangeType();
			toggleCustomHours();
		}

		// Populate app versions dynamically
		async function loadAvailableAppVersions() {
			if (!isAuthenticated) return;
			
			try {
				const query = `
					SELECT 
						app_display_version,
						SUM(usage_count) as total_usage_count
					FROM (
						SELECT DISTINCT
							app_display_version,
							app_build_version,
							COUNT(*) as usage_count
						FROM \`${CONFIG.PROJECT_ID}.${CONFIG.DATASET_ID}.crash_analytics_dashboard\`
						WHERE app_display_version IS NOT NULL
						  AND TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)
						GROUP BY app_display_version, app_build_version
					)
					GROUP BY app_display_version
					ORDER BY 
						CAST(REGEXP_EXTRACT(app_display_version, r'^(\\d+)') AS INT64) DESC,
						CAST(REGEXP_EXTRACT(app_display_version, r'\\.(\\d+)') AS INT64) DESC,
						CAST(REGEXP_EXTRACT(app_display_version, r'\\.(\\d+)$') AS INT64) DESC,
						total_usage_count DESC
					LIMIT 15
				`;

				const result = await executeBigQuery(query);
				if (result.rows && result.rows.length > 0) {
					availableAppVersions = result.rows.map(row => ({
						display_version: row.f[0]?.v || '',
						usage_count: parseInt(row.f[1]?.v) || 0,
						label: `${row.f[0]?.v || 'Unknown'}`
					}));

					// Populate app version options (preserve the actions bar)
					const optionsContainer = document.getElementById('appVersionOptions');
					const actionsHtml = optionsContainer.querySelector('.multi-select-actions')?.outerHTML || '';
					const optionsHtml = availableAppVersions.map((version, index) => `
						<div class="multi-select-option">
							<input type="checkbox" id="app_version_${index}" value="${version.display_version}">
							<label for="app_version_${index}">${version.label} (${version.usage_count} events)</label>
						</div>
					`).join('');
					optionsContainer.innerHTML = actionsHtml + optionsHtml;
				}
			} catch (error) {
				console.error('Failed to load app versions:', error);
			}
		}

		// Initialize all filter components
		function initializeFilterComponents() {
			initializeDateRangeControls();
			initializeMultiSelect('memoryMultiSelect', 'memoryOptions', 'memoryDropdown');
			initializeMultiSelect('appVersionMultiSelect', 'appVersionOptions', 'appVersionDropdown');
		}

		// Execute search when user clicks the Search button
		function executeSearch() {
			if (!isAuthenticated) {
				authenticate();
				return;
			}
			refreshData();
		}

		// Enable/disable search button based on authentication
		function updateSearchButtonState() {
			const searchButton = document.getElementById('searchButton');
			if (searchButton) {
				searchButton.disabled = !isAuthenticated;
			}
		}

		// Select all options in a multi-select dropdown
		function selectAllOptions(optionsId) {
			const options = document.getElementById(optionsId);
			const checkboxes = options.querySelectorAll('input[type="checkbox"]');
			checkboxes.forEach(checkbox => {
				checkbox.checked = true;
			});
			
			// Update display for the affected multi-select
			const multiSelectContainer = options.closest('.multi-select');
			const containerId = multiSelectContainer.id;
			const dropdownId = multiSelectContainer.querySelector('.multi-select-dropdown').id;
			updateMultiSelectDisplay(containerId, optionsId, dropdownId);
		}

		// Clear all options in a multi-select dropdown
		function clearAllOptions(optionsId) {
			const options = document.getElementById(optionsId);
			const checkboxes = options.querySelectorAll('input[type="checkbox"]');
			checkboxes.forEach(checkbox => {
				checkbox.checked = false;
			});
			
			// Update display for the affected multi-select
			const multiSelectContainer = options.closest('.multi-select');
			const containerId = multiSelectContainer.id;
			const dropdownId = multiSelectContainer.querySelector('.multi-select-dropdown').id;
			updateMultiSelectDisplay(containerId, optionsId, dropdownId);
		}

		// Show no results modal
		function showNoResultsModal() {
			document.getElementById('noResultsModal').classList.add('show');
		}

		// Close no results modal
		function closeNoResultsModal() {
			document.getElementById('noResultsModal').classList.remove('show');
		}

		// Clear all filters and perform a new search
		function clearAllFiltersAndSearch() {
			// Reset date range to default
			document.getElementById('relativeDateType').checked = true;
			document.getElementById('dateRange').value = '7'; // Last 7 days
			
			// Clear single selects
			document.getElementById('platformFilter').value = '';
			document.getElementById('riskFilter').value = '';
			document.getElementById('sourceFilter').value = '';
			document.getElementById('crashTypeFilter').value = '';
			
			// Clear multi-select filters
			clearAllOptions('memoryOptions');
			clearAllOptions('appVersionOptions');
			
			// Update date range display
			const relativeDateContainer = document.getElementById('relativeDateContainer');
			const absoluteDateContainer = document.getElementById('absoluteDateContainer');
			relativeDateContainer.style.display = 'block';
			absoluteDateContainer.style.display = 'none';
			
			// Reset table sorting to default
			userTableSort = { column: 'risk', direction: 'desc' };
			originalUserTableData = [];
			
			// Close the modal
			closeNoResultsModal();
			
			// Execute search with cleared filters
			executeSearch();
		}

		// Check if results are empty/meaningless
		function hasNoMeaningfulResults(metrics) {
			// Check if all main metrics are zero or empty
			const hasZeroMetrics = (
				metrics.totalCrashes === 0 &&
				metrics.affectedUsers === 0 &&
				metrics.fatalCrashes === 0 &&
				metrics.nonFatalCrashes === 0
			);
			
			// Check if all data arrays are empty
			const hasNoArrayData = (
				(!metrics.dailyTrend || metrics.dailyTrend.length === 0) &&
				(!metrics.deviceStats || metrics.deviceStats.length === 0) &&
				(!metrics.errorTypes || metrics.errorTypes.length === 0) &&
				(!metrics.highRiskUsers || metrics.highRiskUsers.length === 0)
			);
			
			return hasZeroMetrics || hasNoArrayData;
		}

		// Initialize both APIs and restore session
		async function initializeAPIs() {
			if (gapiInited && gisInited) {
				try {
					await gapi.client.init({
						apiKey: CONFIG.API_KEY,
						discoveryDocs: CONFIG.DISCOVERY_DOCS
					});
					console.log('GAPI client initialized');
					
					if (!CONFIG.CLIENT_ID || CONFIG.CLIENT_ID === 'YOUR_CLIENT_ID.apps.googleusercontent.com') return;
					tokenClient = google.accounts.oauth2.initTokenClient({
						client_id: CONFIG.CLIENT_ID,
						scope: CONFIG.SCOPES,
						callback: '', // Use empty string to handle the response manually
						error_callback: (err) => {
							console.error('GIS error:', err);
							alert('Failed to authenticate. Please try again.');
						}
					});
					
					await restoreSession();
				} catch (e) {
					console.error('Failed to initialize APIs:', e);
					alert('Error initializing Google APIs. Please check console for details.');
				}
			}
		}

		// gapi load callback
		function gapiLoaded() {
			gapi.load('client', () => {
				gapiInited = true;
				initializeAPIs();
			});
		}

		// GIS load callback
		function gisLoaded() {
			gisInited = true;
			initializeAPIs();
		}

		function authenticate() {
			if (!validateConfig()) return;
			if (!gapiInited || !gisInited) {
				document.getElementById('authModal').classList.add('show');
				return;
			}
			document.getElementById('authModal').classList.add('show');
		}

		async function signIn() {
			if (!validateConfig()) return;
			if (!tokenClient) {
				console.warn('Token client not ready yet.');
				return;
			}
			try {
				// Request token and wait for response
				const response = await new Promise((resolve, reject) => {
					try {
						tokenClient.callback = (resp) => {
							if (resp.error) {
								reject(resp);
							}
							resolve(resp);
						};
						tokenClient.requestAccessToken({ prompt: accessToken ? '' : 'consent' });
					} catch (err) {
						reject(err);
					}
				});

				// Handle successful authentication
				accessToken = response.access_token;
				localStorage.setItem('bq_access_token', accessToken);
				gapi.client.setToken({ access_token: accessToken });
				isAuthenticated = true;
				
				// Update UI
				document.getElementById('connectionStatus').className = 'status connected';
				document.getElementById('connectionStatus').innerHTML = '<span class="status-dot"></span><span>Connected</span>';
				document.getElementById('authBtn').textContent = '‚úì Connected';
				document.getElementById('refreshBtn').disabled = false;
				document.getElementById('authModal').classList.remove('show');
				
				// Initialize filter components and load data
				initializeFilterComponents();
				await loadAvailableAppVersions();
				updateSearchButtonState();
				await refreshData(); // Initial load
			} catch (error) {
				console.error('Authentication failed:', error);
				alert('Failed to authenticate. Please try again.');
			}
		}

		function signOut() {
			accessToken = null;
			gapi.client.setToken(null);
			isAuthenticated = false;
			document.getElementById('connectionStatus').className = 'status disconnected';
			document.getElementById('connectionStatus').innerHTML = '<span class="status-dot"></span><span>Disconnected</span>';
			document.getElementById('authBtn').textContent = 'üîê Connect to BigQuery';
			document.getElementById('refreshBtn').disabled = true;
			updateSearchButtonState();
		}

		function openSettings() {
			document.getElementById('cfgClientId').value = CONFIG.CLIENT_ID || '';
			document.getElementById('cfgApiKey').value = CONFIG.API_KEY || '';
			document.getElementById('settingsModal').classList.add('show');
		}

		function closeSettings() {
			document.getElementById('settingsModal').classList.remove('show');
		}

		function saveSettings() {
			const cid = document.getElementById('cfgClientId').value.trim();
			const key = document.getElementById('cfgApiKey').value.trim();
			if (!cid) { alert('Client ID is required.'); return; }
			localStorage.setItem('bq_client_id', cid);
			CONFIG.CLIENT_ID = cid;
			if (key) { localStorage.setItem('bq_api_key', key); CONFIG.API_KEY = key; }
			closeSettings();
			if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
				initGISTokenClient();
			}
			alert('Settings saved. You can now Connect.');
		}

		// Build SQL query with filters
		function buildQuery() {
			const platform = document.getElementById('platformFilter').value;
			const riskLevel = document.getElementById('riskFilter').value;
			const source = document.getElementById('sourceFilter').value;

			let whereConditions = [];
			const baseTable = `\`${CONFIG.PROJECT_ID}.${CONFIG.DATASET_ID}.crash_analytics_dashboard\``;
			
			// Build date filter based on selected range type
			let dateFilter;
			const dateRangeType = document.querySelector('input[name="dateRangeType"]:checked')?.value || 'relative';
			
			if (dateRangeType === 'absolute') {
				// Use absolute date range
				const dateFrom = document.getElementById('dateFrom').value;
				const dateTo = document.getElementById('dateTo').value;
				
				if (dateFrom && dateTo) {
					// Convert date format (YYYY-MM-DD) to BigQuery timestamp format with time bounds
					const formatDateForBigQuery = (dateOnly, isEndDate = false) => {
						if (!dateOnly) return null;
						// Add time component - start of day for from date, end of day for to date
						return isEndDate ? `${dateOnly} 23:59:59` : `${dateOnly} 00:00:00`;
					};
					
					const formattedDateFrom = formatDateForBigQuery(dateFrom, false);
					const formattedDateTo = formatDateForBigQuery(dateTo, true);
					
					dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP('${formattedDateFrom}') 
								  AND TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) <= TIMESTAMP('${formattedDateTo}')`;
					console.log('Using absolute date range:', formattedDateFrom, 'to', formattedDateTo);
				} else {
					// Fallback to last 24 hours if dates not set
					dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 DAY)`;
					console.log('Absolute dates not set, fallback to last 24 hours');
				}
			} else {
				// Use relative date range
				const dateRange = document.getElementById('dateRange').value;
				
				if (dateRange === 'custom_hours') {
					const customHours = document.getElementById('customHours').value || '12';
					dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL ${customHours} HOUR)`;
					console.log('Using custom hours:', customHours);
				} else if (dateRange === 'hour') {
					dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 HOUR)`;
				} else {
					dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL ${dateRange} DAY)`;
				}
				console.log('Date range:', dateRange, 'Date filter:', dateFilter);
			}

			if (platform) {
				whereConditions.push(`platform = '${platform}'`);
			}

			if (riskLevel) {
				whereConditions.push(`user_risk_score >= ${riskLevel}`);
			}

			if (source) {
				whereConditions.push(`data_source = '${source}'`);
			}

			const crashType = document.getElementById('crashTypeFilter').value;
			console.log('Current crash type filter value:', crashType);
			if (crashType === 'fatal') {
				whereConditions.push('is_fatal = TRUE');
				console.log('Added filter: is_fatal = TRUE');
			} else if (crashType === 'non-fatal') {
				whereConditions.push('is_fatal = FALSE');
				console.log('Added filter: is_fatal = FALSE');
			}

			// Handle multi-select memory filters
			const memoryFilters = getMultiSelectValues('memoryOptions');
			console.log('Current memory filters:', memoryFilters);
			if (memoryFilters.length > 0) {
				const memoryConditions = [];
				memoryFilters.forEach(filter => {
					switch(filter) {
						case 'critical':
							memoryConditions.push('avg_memory_free_mb < 50');
							break;
						case 'low':
							memoryConditions.push('(avg_memory_free_mb >= 50 AND avg_memory_free_mb < 100)');
							break;
						case 'medium':
							memoryConditions.push('(avg_memory_free_mb >= 100 AND avg_memory_free_mb < 200)');
							break;
						case 'good':
							memoryConditions.push('(avg_memory_free_mb >= 200 AND avg_memory_free_mb < 500)');
							break;
						case 'excellent':
							memoryConditions.push('avg_memory_free_mb >= 500');
							break;
					}
				});
				if (memoryConditions.length > 0) {
					whereConditions.push(`(${memoryConditions.join(' OR ')})`);
					console.log('Added memory filter:', memoryConditions.join(' OR '));
				}
			}

			// Handle multi-select app version filters
			const appVersionFilters = getMultiSelectValues('appVersionOptions');
			console.log('Current app version filters:', appVersionFilters);
			if (appVersionFilters.length > 0) {
				const versionConditions = appVersionFilters.map(displayVersion => 
					`app_display_version = '${displayVersion}'`
				);
				whereConditions.push(`(${versionConditions.join(' OR ')})`);
				console.log('Added app version filter:', versionConditions.join(' OR '));
			}

			console.log('All where conditions:', whereConditions);
			
			const finalQuery = `
				WITH filtered_data AS (
					SELECT *
					FROM ${baseTable}
					WHERE ${dateFilter}
					${whereConditions.length > 0 ? 'AND ' + whereConditions.join(' AND ') : ''}
				),
				time_stats AS (
					SELECT 
						time_bucket,
						platform,
						COUNT(DISTINCT user_id) as users,
						COUNT(*) as crashes
					FROM (
						SELECT
							CASE 
								WHEN '${dateRange}' = 'hour' THEN 
									FORMAT_TIMESTAMP('%Y-%m-%d %H:00:00', TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)))
								ELSE 
									FORMAT_TIMESTAMP('%Y-%m-%d', TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)))
							END as time_bucket,
							platform,
							user_id,
							total_error_count
						FROM filtered_data
					)
					GROUP BY time_bucket, platform
					ORDER BY time_bucket ASC
				),
				device_stats AS (
					SELECT 
						COALESCE(device_model, 'Unknown') as device_model,
						platform,
						COUNT(DISTINCT user_id) as affected_users,
						COUNT(*) as crash_count,
						SUM(total_error_count) as total_errors,
						AVG(user_risk_score) as avg_risk_score
					FROM filtered_data
					WHERE device_model IS NOT NULL
					GROUP BY device_model, platform
					ORDER BY crash_count DESC
				),
				error_stats AS (
					SELECT 
						COALESCE(crashlytics_error_type, sentry_latest_error, 'Unknown') as error_type,
						COUNT(*) as error_count,
						STRING_AGG(DISTINCT COALESCE(sentry_latest_error, 'No details')) as error_details,
						platform
					FROM filtered_data
					WHERE COALESCE(crashlytics_error_type, sentry_latest_error) IS NOT NULL
					GROUP BY error_type, platform
					ORDER BY error_count DESC
				),
				user_stats AS (
					SELECT 
						user_id,
						platform,
						user_email,
						user_username,
						user_name,
						country_code,
						city,
						region,
						device_model,
						app_display_version,
						app_build_version,
						os_display_version,
						crashlytics_issue_id,
						crashlytics_issue_title,
						crashlytics_error_type,
						is_fatal,
						crashlytics_event_count,
						crashlytics_first_occurrence,
						crashlytics_last_occurrence,
						avg_memory_used_mb,
						avg_memory_free_mb,
						sentry_total_errors,
						sentry_unique_issues,
						sentry_latest_error,
						sentry_first_seen,
						sentry_last_seen,
						total_error_count,
						data_source,
						has_correlated_errors,
						user_risk_score,
						error_percentile,
						error_count_rank,
						platform_error_percentile,
						platform_error_rank,
						error_duration_hours,
						errors_per_hour,
						top_sentry_errors_json
					FROM filtered_data
					WHERE user_risk_score >= 75
					ORDER BY user_risk_score DESC, total_error_count DESC
				),
				fatality_stats AS (
					SELECT
						platform,
						COUNTIF(is_fatal) as fatal_count,
						COUNT(*) - COUNTIF(is_fatal) as non_fatal_count
					FROM filtered_data
					GROUP BY platform
				),
				-- Get comparison data from previous period for trend calculations (temporarily disabled for debugging)
				comparison_data AS (
					SELECT 
						0 as prev_affected_users,
						0 as prev_total_crashes,
						0 as prev_fatal_crashes,
						0 as prev_non_fatal_crashes,
						0.0 as prev_avg_risk_score
				),
				version_stats AS (
					SELECT 
						CONCAT(app_display_version, ' (', app_build_version, ')') as version_string,
						COUNT(*) as crash_count,
						COUNT(DISTINCT user_id) as affected_users
					FROM filtered_data
					WHERE app_display_version IS NOT NULL
					GROUP BY app_display_version, app_build_version
					ORDER BY crash_count DESC
					LIMIT 1
				),
				app_version_breakdown AS (
					SELECT 
						CASE 
							WHEN '${dateRange}' = 'hour' THEN 
								FORMAT_TIMESTAMP('%Y-%m-%d %H:00:00', TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)))
							ELSE 
								FORMAT_TIMESTAMP('%Y-%m-%d', TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)))
						END as time_bucket,
						app_display_version,
						app_build_version,
						CONCAT(app_display_version, ' (', app_build_version, ')') as version_string,
						COUNT(*) as total_events,
						COUNTIF(is_fatal) as crashes,
						COUNT(*) - COUNTIF(is_fatal) as errors,
						COUNT(DISTINCT user_id) as affected_users
					FROM filtered_data
					WHERE app_display_version IS NOT NULL
					GROUP BY time_bucket, app_display_version, app_build_version
					ORDER BY time_bucket, total_events DESC
				),
				memory_breakdown AS (
					SELECT 
						CASE 
							WHEN avg_memory_free_mb IS NULL THEN 'Unknown'
							WHEN avg_memory_free_mb < 50 THEN 'Critical (<50MB)'
							WHEN avg_memory_free_mb < 100 THEN 'Low (50-100MB)'
							WHEN avg_memory_free_mb < 200 THEN 'Medium (100-200MB)'
							WHEN avg_memory_free_mb < 500 THEN 'Good (200-500MB)'
							ELSE 'Excellent (>500MB)'
						END as memory_category,
						COUNT(*) as total_events,
						COUNTIF(is_fatal) as crashes,
						COUNT(*) - COUNTIF(is_fatal) as errors,
						COUNT(DISTINCT user_id) as affected_users,
						AVG(avg_memory_free_mb) as avg_free_memory,
						MIN(avg_memory_free_mb) as min_free_memory,
						MAX(avg_memory_free_mb) as max_free_memory
					FROM filtered_data
					WHERE avg_memory_free_mb IS NOT NULL
					GROUP BY memory_category
					ORDER BY 
						CASE 
							WHEN memory_category = 'Critical (<50MB)' THEN 1
							WHEN memory_category = 'Low (50-100MB)' THEN 2
							WHEN memory_category = 'Medium (100-200MB)' THEN 3
							WHEN memory_category = 'Good (200-500MB)' THEN 4
							WHEN memory_category = 'Excellent (>500MB)' THEN 5
							ELSE 6
						END
				),
				crash_names_breakdown AS (
					SELECT 
						COALESCE(crashlytics_issue_title, sentry_latest_error, 'Unknown Error') as crash_name,
						platform,
						COUNT(*) as total_events,
						COUNTIF(is_fatal) as crashes,
						COUNT(*) - COUNTIF(is_fatal) as errors,
						COUNT(DISTINCT user_id) as affected_users,
						AVG(avg_memory_free_mb) as avg_memory_free,
						AVG(user_risk_score) as avg_risk_score
					FROM filtered_data
					WHERE (crashlytics_issue_title IS NOT NULL OR sentry_latest_error IS NOT NULL)
					GROUP BY crash_name, platform
					ORDER BY total_events DESC
					LIMIT 15
				),
				metrics AS (
					SELECT
						COUNT(DISTINCT user_id) as affected_users,
						COUNT(*) as total_crashes,
						COUNTIF(is_fatal) as fatal_crashes,
						COUNT(*) - COUNTIF(is_fatal) as non_fatal_crashes,
						AVG(user_risk_score) as avg_risk_score,
						COUNTIF(platform = 'IOS') as ios_users,
						COUNTIF(platform = 'ANDROID') as android_users
					FROM filtered_data
				),
				comparison_metrics AS (
					SELECT 
						0 as prev_affected_users,
						0 as prev_total_crashes,
						0 as prev_fatal_crashes,
						0 as prev_non_fatal_crashes,
						0.0 as prev_avg_risk_score
				)
								SELECT 
					metrics.*,
					comparison_metrics.prev_affected_users,
					comparison_metrics.prev_total_crashes,
					comparison_metrics.prev_fatal_crashes,
					comparison_metrics.prev_non_fatal_crashes,
					comparison_metrics.prev_avg_risk_score,
					COALESCE(version_stats.version_string, 'Unknown') as top_app_version,
					COALESCE(version_stats.crash_count, 0) as top_version_crashes,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(STRUCT(
							platform,
							fatal_count,
							non_fatal_count
						)))
						FROM fatality_stats
					) as fatality_stats_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(STRUCT(
							time_bucket,
							version_string,
							app_display_version,
							app_build_version,
							total_events,
							crashes,
							errors,
							affected_users
						) ORDER BY time_bucket, total_events DESC))
						FROM app_version_breakdown
					) as app_version_breakdown_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(STRUCT(
							memory_category,
							total_events,
							crashes,
							errors,
							affected_users,
							avg_free_memory,
							min_free_memory,
							max_free_memory
						) ORDER BY 
							CASE 
								WHEN memory_category = 'Critical (<50MB)' THEN 1
								WHEN memory_category = 'Low (50-100MB)' THEN 2
								WHEN memory_category = 'Medium (100-200MB)' THEN 3
								WHEN memory_category = 'Good (200-500MB)' THEN 4
								WHEN memory_category = 'Excellent (>500MB)' THEN 5
								ELSE 6
							END))
						FROM memory_breakdown
					) as memory_breakdown_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(STRUCT(
							crash_name,
							platform,
							total_events,
							crashes,
							errors,
							affected_users,
							avg_memory_free,
							avg_risk_score
						) ORDER BY total_events DESC))
						FROM crash_names_breakdown
					) as crash_names_breakdown_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(t))
						FROM (
							SELECT STRUCT(time_bucket, platform, users, crashes) as t
							FROM time_stats
							ORDER BY time_bucket, platform
						)
					) as daily_trend_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(t))
						FROM (
							SELECT STRUCT(
								device_model,
								platform,
								crash_count,
								affected_users,
								total_errors,
								CAST(avg_risk_score AS FLOAT64) as avg_risk_score
							) as t
							FROM device_stats
							ORDER BY crash_count DESC
							LIMIT 10
						)
					) as device_stats_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(t))
						FROM (
							SELECT STRUCT(
								error_type,
								error_count,
								error_details,
								platform
							) as t
							FROM error_stats
							ORDER BY error_count DESC
							LIMIT 20
						)
					) as error_types_json,
					(
						SELECT TO_JSON_STRING(ARRAY_AGG(STRUCT(
							user_id,
							platform,
							device_model,
							total_error_count as errors,
							user_risk_score as risk,
							CASE 
								WHEN TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), COALESCE(crashlytics_last_occurrence, sentry_last_seen), HOUR) <= 24 
								THEN total_error_count 
								ELSE 0 
							END as last_24h,
							data_source as source,
							FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S', COALESCE(crashlytics_last_occurrence, sentry_last_seen)) as last_seen,
							crashlytics_issue_title,
							crashlytics_error_type,
							is_fatal,
							avg_memory_used_mb,
							avg_memory_free_mb,
							sentry_latest_error,
							sentry_total_errors,
							sentry_unique_issues,
							has_correlated_errors,
							error_duration_hours,
							errors_per_hour,
							top_sentry_errors_json
						) ORDER BY user_risk_score DESC, total_error_count DESC))
						FROM user_stats
					) as high_risk_users_json
				FROM metrics
				CROSS JOIN comparison_metrics
				LEFT JOIN version_stats ON TRUE
			`;
			
			console.log('Final BigQuery:', finalQuery);
			
			// Add a simple test query to verify is_fatal field
			if (crashType === 'fatal') {
				console.log('DEBUG: Testing is_fatal field...');
				const testQuery = `
					SELECT 
						is_fatal,
						COUNT(*) as count
					FROM ${baseTable}
					WHERE ${dateFilter}
					GROUP BY is_fatal
					ORDER BY is_fatal
				`;
				console.log('Test query for is_fatal distribution:', testQuery);
			}
			
			return finalQuery;
		}

		// Execute BigQuery
		async function executeBigQuery(query) {
			try {
				console.log('Executing query:', query);
				
				// Verify token is still valid
				if (!accessToken) {
					throw new Error('Not authenticated');
				}

				// Set up request
				const request = {
					query: query,
					useLegacySql: false,
					maxResults: 1000,
					timeoutMs: 30000
				};

				// Execute query with retry logic
				let retryCount = 0;
				const maxRetries = 3;
				
				while (retryCount < maxRetries) {
					try {
						const response = await gapi.client.bigquery.jobs.query({
							projectId: CONFIG.PROJECT_ID,
							resource: request
						});

						console.log('BigQuery Response:', response);

						if (response.result.error) {
							throw new Error(response.result.error.message);
						}

						return response.result;
					} catch (error) {
						// Check if error is due to auth
						if (error.status === 401 || error.status === 403) {
							console.log('Auth error, attempting to refresh token...');
							await signIn();
							retryCount++;
							continue;
						}
						
						// For other errors, retry after a delay
						if (retryCount < maxRetries - 1) {
							console.log(`Retry ${retryCount + 1} of ${maxRetries}...`);
							await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
							retryCount++;
							continue;
						}
						
						// If all retries failed, throw the error
						throw error;
					}
				}
				
				throw new Error('Failed to execute query after multiple retries');
			} catch (error) {
				// Log the full error object
				console.error('BigQuery Error Details:', {
					error,
					message: error.message,
					status: error.status,
					result: error.result,
					body: error.body
				});

				// Show a more detailed error message
				const errorMessage = error.result?.error?.message || error.message || 'Unknown error';
				alert('BigQuery Error: ' + errorMessage);
				
				// If auth error, clear token and show auth modal
				if (error.status === 401 || error.status === 403) {
					localStorage.removeItem('bq_access_token');
					accessToken = null;
					isAuthenticated = false;
					document.getElementById('authModal').classList.add('show');
				}
				
				throw error;
			}
		}

		// Refresh dashboard data
		async function refreshData() {
			if (!isAuthenticated || !accessToken || !gapiInited) {
				authenticate();
				return;
			}

			// Show loading state
			const loadingOverlay = document.getElementById('loadingOverlay');
			const loadingMessage = document.getElementById('loadingMessage');
			const connectionStatus = document.getElementById('connectionStatus');
			const metricCards = document.querySelectorAll('.metric-card');
			const lastUpdated = document.getElementById('lastUpdated');

			try {
				// Set loading state
				loadingOverlay.classList.add('show');
				loadingMessage.textContent = 'Querying BigQuery...';
				connectionStatus.className = 'status loading';
				connectionStatus.innerHTML = '<span class="status-dot"></span><span>Loading...</span>';
				metricCards.forEach(card => card.classList.add('loading'));

				// Clear previous data
				document.getElementById('totalCrashes').textContent = '-';
				document.getElementById('affectedUsers').textContent = '-';
				document.getElementById('fatalCrashes').textContent = '-';
				document.getElementById('nonFatalCrashes').textContent = '-';
				document.getElementById('avgRiskScore').textContent = '-';
				document.getElementById('eventsPerUser').textContent = '-';
				document.getElementById('usersSubtitle').textContent = 'Loading...';
				document.getElementById('topAppVersion').textContent = '-';
				document.getElementById('crashChange').textContent = 'Loading...';
				document.getElementById('userChange').textContent = 'Loading...';
				document.getElementById('fatalChange').textContent = 'Loading...';
				document.getElementById('nonFatalChange').textContent = 'Loading...';
				document.getElementById('riskChange').textContent = 'Loading...';

				// Execute query
				const query = buildQuery();
				console.log('Executing query:', query);
				const result = await executeBigQuery(query);

				if (!result.rows || result.rows.length === 0) {
					throw new Error('No data returned from BigQuery');
				}

				const data = result.rows[0].f;
				console.log('Raw BigQuery response:', data);
				console.log('Data array length:', data.length);
				console.log('Data indices and types:', data.map((item, index) => ({index, type: typeof item?.v, value: item?.v?.substring ? item.v.substring(0, 100) : item?.v})));

							// Parse metrics with safe fallbacks
			const safeParseJSON = (value, fallback = []) => {
				try {
					if (value && value !== 'null' && value !== 'undefined') {
						return JSON.parse(value);
					}
					return fallback;
				} catch (e) {
					console.warn('Failed to parse JSON:', e, 'Value:', value);
					return fallback;
				}
			};

			const metrics = {
				affectedUsers: parseInt(data[0]?.v) || 0,
				totalCrashes: parseInt(data[1]?.v) || 0,
				fatalCrashes: parseInt(data[2]?.v) || 0,
				nonFatalCrashes: parseInt(data[3]?.v) || 0,
				avgRiskScore: parseFloat(data[4]?.v || '0').toFixed(1),
				iosUsers: parseInt(data[5]?.v) || 0,
				androidUsers: parseInt(data[6]?.v) || 0,
				// Comparison metrics for trend calculations
				prevAffectedUsers: parseInt(data[7]?.v) || 0,
				prevTotalCrashes: parseInt(data[8]?.v) || 0,
				prevFatalCrashes: parseInt(data[9]?.v) || 0,
				prevNonFatalCrashes: parseInt(data[10]?.v) || 0,
				prevAvgRiskScore: parseFloat(data[11]?.v || '0'),
				// App version data
				topAppVersion: data[12]?.v || 'Unknown',
				topVersionCrashes: parseInt(data[13]?.v) || 0,
				fatalityStats: safeParseJSON(data[14]?.v, []),
				appVersionBreakdown: safeParseJSON(data[15]?.v, []),
				memoryBreakdown: safeParseJSON(data[16]?.v, []),
				crashNamesBreakdown: safeParseJSON(data[17]?.v, [])
			};

				// Parse JSON data with validation using safe parsing
				try {
					// Daily trend data
					console.log('Parsing daily trend data from index:', 18, 'Raw value:', data[18]?.v);
					const dailyTrend = safeParseJSON(data[18]?.v, []);
					console.log('Parsed daily trend:', dailyTrend);
					
					metrics.dailyTrend = Array.isArray(dailyTrend) ? dailyTrend.map(d => ({
						time_bucket: d?.time_bucket || '',
						platform: d?.platform || 'Unknown',
						daily_users: parseInt(d?.users) || 0,
						daily_crashes: parseInt(d?.crashes) || 0
					})) : [];

					// Device stats
					const deviceStats = safeParseJSON(data[19]?.v, []);
					console.log('Raw device stats:', deviceStats);
					
					metrics.deviceStats = Array.isArray(deviceStats) ? deviceStats.map(d => ({
						device_model: d?.device_model || 'Unknown',
						platform: d?.platform || 'Unknown',
						crash_count: parseInt(d?.crash_count) || 0,
						affected_users: parseInt(d?.affected_users) || 0,
						total_errors: parseInt(d?.total_errors) || 0,
						avg_risk_score: parseFloat(d?.avg_risk_score) || 0
					})) : [];

					// Error types
					const errorTypes = safeParseJSON(data[20]?.v, []);
					console.log('Raw error types:', errorTypes);
					
					metrics.errorTypes = Array.isArray(errorTypes) ? errorTypes.map(d => ({
						error_type: d?.error_type || 'Unknown',
						error_count: parseInt(d?.error_count) || 0,
						error_details: d?.error_details || '',
						platform: d?.platform || 'Unknown'
					})) : [];

					// High risk users
					const highRiskUsers = safeParseJSON(data[21]?.v, []);
					console.log('Raw high risk users:', highRiskUsers);
					
					metrics.highRiskUsers = Array.isArray(highRiskUsers) ? highRiskUsers.map(d => ({
						user_id: d?.user_id || 'Unknown',
						platform: d?.platform || 'Unknown',
						device_model: d?.device_model || 'Unknown',
						errors: parseInt(d?.errors) || 0,
						risk: parseFloat(d?.risk) || 0,
						last_24h: parseInt(d?.last_24h) || 0,
						source: d?.source || 'Unknown',
						last_seen: d?.last_seen || 'Unknown',
						// Direct field mapping from BigQuery view
						crashlytics_issue_title: d?.crashlytics_issue_title || 'N/A',
						crashlytics_error_type: d?.crashlytics_error_type || 'N/A',
						is_fatal: d?.is_fatal === true || d?.is_fatal === 'true',
						avg_memory_used_mb: parseFloat(d?.avg_memory_used_mb) || 0,
						avg_memory_free_mb: parseFloat(d?.avg_memory_free_mb) || 0,
						sentry_latest_error: d?.sentry_latest_error || 'N/A',
						sentry_total_errors: parseInt(d?.sentry_total_errors) || 0,
						sentry_unique_issues: parseInt(d?.sentry_unique_issues) || 0,
						has_correlated_errors: d?.has_correlated_errors === true || d?.has_correlated_errors === 'true',
						error_duration_hours: parseInt(d?.error_duration_hours) || 0,
						errors_per_hour: parseFloat(d?.errors_per_hour) || 0,
						top_sentry_errors_json: d?.top_sentry_errors_json || '[]'
					})) : [];

					console.log('Parsed and validated metrics:', metrics);
				} catch (e) {
					console.error('Error parsing JSON data:', e);
					console.log('Raw JSON data:', {
						appVersionBreakdown: data[15]?.v,
						memoryBreakdown: data[16]?.v,
						crashNamesBreakdown: data[17]?.v,
						dailyTrend: data[18]?.v,
						deviceStats: data[19]?.v,
						errorTypes: data[20]?.v,
						highRiskUsers: data[21]?.v
					});
					
					// Set fallback empty arrays for all collections to prevent chart errors
					console.warn('Using fallback empty data due to JSON parsing error');
					metrics.dailyTrend = [];
					metrics.deviceStats = [];
					metrics.errorTypes = [];
					metrics.highRiskUsers = [];
				}

				// Check if we have meaningful results
				if (hasNoMeaningfulResults(metrics)) {
					console.log('No meaningful results found, showing modal');
					showNoResultsModal();
					
					// Reset table data and update the UI with empty data to reset any previous results
					originalUserTableData = [];
					updateMetrics(metrics);
				} else {
					// Reset table data for new search results and update UI
					originalUserTableData = [];
					updateMetrics(metrics);
				}
				
				const now = new Date();
				lastUpdated.textContent = `Last updated: ${now.toLocaleTimeString()} ${now.toLocaleDateString()}`;

				// Update connection status
				connectionStatus.className = 'status connected';
				connectionStatus.innerHTML = '<span class="status-dot"></span><span>Connected</span>';
				document.getElementById('exportCsv').disabled = false;

			} catch (error) {
				console.error('Error refreshing data:', error);
				alert('Error loading data: ' + error.message);
				
				// Reset UI on error
				connectionStatus.className = 'status disconnected';
				connectionStatus.innerHTML = '<span class="status-dot"></span><span>Error</span>';
				
				// Clear charts
				Object.values(charts).forEach(chart => chart?.destroy());
				charts = {};
				
			} finally {
				// Reset loading state
				loadingOverlay.classList.remove('show');
				metricCards.forEach(card => card.classList.remove('loading'));
			}
		}

		function updateMetrics(data) {
			// Get current filter to show/hide relevant metrics
			const crashTypeFilter = document.getElementById('crashTypeFilter').value;
			
			// Cache DOM elements
			const elements = {
				totalCrashes: document.getElementById('totalCrashes'),
				affectedUsers: document.getElementById('affectedUsers'),
				fatalCrashes: document.getElementById('fatalCrashes'),
				avgRiskScore: document.getElementById('avgRiskScore'),
				crashChange: document.getElementById('crashChange'),
				userChange: document.getElementById('userChange'),
				fatalChange: document.getElementById('fatalChange'),
				riskChange: document.getElementById('riskChange')
			};

			// Get metric card containers for show/hide
			const fatalCard = elements.fatalCrashes.closest('.metric-card');
			const nonFatalCard = document.getElementById('nonFatalCrashes').closest('.metric-card');

			// Format numbers
			const formatNumber = (num) => {
				if (typeof num !== 'number') return '0';
				return num.toLocaleString();
			};

			// Update main metrics with proper formatting
			elements.totalCrashes.textContent = formatNumber(data.totalCrashes);
			elements.affectedUsers.textContent = formatNumber(data.affectedUsers);
			elements.fatalCrashes.textContent = formatNumber(data.fatalCrashes);
			document.getElementById('nonFatalCrashes').textContent = formatNumber(data.nonFatalCrashes);
			elements.avgRiskScore.textContent = parseFloat(data.avgRiskScore).toFixed(1);
			document.getElementById('topAppVersion').textContent = data.topAppVersion || 'Unknown';

			// Calculate and display events per user with correct terminology
			const eventsPerUser = data.affectedUsers > 0 ? (data.totalCrashes / data.affectedUsers).toFixed(1) : 0;
			let subtitleText = '';
			let usersSubtitleText = '';
			
			if (crashTypeFilter === 'fatal') {
				subtitleText = `${eventsPerUser} crashes per user`;
				usersSubtitleText = 'users experienced crashes';
			} else if (crashTypeFilter === 'non-fatal') {
				subtitleText = `${eventsPerUser} errors per user`;
				usersSubtitleText = 'users experienced errors';
			} else {
				subtitleText = `${eventsPerUser} events per user`;
				usersSubtitleText = 'users experienced events';
			}
			
			document.getElementById('eventsPerUser').textContent = subtitleText;
			document.getElementById('usersSubtitle').textContent = usersSubtitleText;

			// Show/hide metrics and update labels based on filter selection
			const totalEventsLabel = elements.totalCrashes.closest('.metric-card').querySelector('.metric-label');
			
			if (crashTypeFilter === 'fatal') {
				// Crashes Only: Hide error metrics, show only crashes, hide duplicate fatal card
				fatalCard.style.display = 'none';  // Hide duplicate fatal card
				nonFatalCard.style.display = 'none';
				totalEventsLabel.textContent = 'Crashes';
			} else if (crashTypeFilter === 'non-fatal') {
				// Errors Only: Hide crash metrics, show only errors
				fatalCard.style.display = 'none';
				nonFatalCard.style.display = 'block';
				totalEventsLabel.textContent = 'Errors';
			} else {
				// All Events: Show breakdown of crashes and errors
				fatalCard.style.display = 'block';
				nonFatalCard.style.display = 'block';
				totalEventsLabel.textContent = 'All Events';
			}

			// Calculate percentage changes using comparison data
			const calculateChange = (current, previous) => {
				if (!previous || previous === 0) return { value: 0, isPositive: false };
				const change = ((current - previous) / previous) * 100;
				return {
					value: Math.abs(change).toFixed(1),
					isPositive: change > 0
				};
			};

			// Calculate changes based on filtered data vs previous period
			const changes = {
				crashes: calculateChange(data.totalCrashes, data.prevTotalCrashes),
				users: calculateChange(data.affectedUsers, data.prevAffectedUsers),
				fatal: calculateChange(data.fatalCrashes, data.prevFatalCrashes),
				nonFatal: calculateChange(data.nonFatalCrashes, data.prevNonFatalCrashes),
				risk: calculateChange(parseFloat(data.avgRiskScore), data.prevAvgRiskScore)
			};

			// Update trend indicators with proper comparison data
			elements.crashChange.textContent = `${changes.crashes.isPositive ? '‚Üë' : '‚Üì'} ${changes.crashes.value}%`;
			elements.crashChange.className = `metric-change ${changes.crashes.isPositive ? 'negative' : 'positive'}`;
			
			elements.userChange.textContent = `${changes.users.isPositive ? '‚Üë' : '‚Üì'} ${changes.users.value}%`;
			elements.userChange.className = `metric-change ${changes.users.isPositive ? 'negative' : 'positive'}`;
			
			elements.fatalChange.textContent = `${changes.fatal.isPositive ? '‚Üë' : '‚Üì'} ${changes.fatal.value}%`;
			elements.fatalChange.className = `metric-change ${changes.fatal.isPositive ? 'negative' : 'positive'}`;
			
			document.getElementById('nonFatalChange').textContent = `${changes.nonFatal.isPositive ? '‚Üë' : '‚Üì'} ${changes.nonFatal.value}%`;
			document.getElementById('nonFatalChange').className = `metric-change ${changes.nonFatal.isPositive ? 'negative' : 'positive'}`;
			
			elements.riskChange.textContent = `${changes.risk.isPositive ? '‚Üë' : '‚Üì'} ${changes.risk.value}%`;
			elements.riskChange.className = `metric-change ${changes.risk.isPositive ? 'negative' : 'positive'}`;

			// Update charts
			updateCharts(data);

			// Update user table
			updateUserTable(data.highRiskUsers || []);


		}

		// Sort state for user table and store the original data
		let userTableSort = {
			column: 'risk',
			direction: 'desc'
		};
		let originalUserTableData = []; // Store the original filtered data

		function updateUserTable(users) {
			const tbody = document.getElementById('userTableBody');
			const table = document.getElementById('userTable');
			const tableLoading = document.getElementById('tableLoading');

			// Clear existing content
			tbody.innerHTML = '';

			if (!users || users.length === 0) {
				tableLoading.style.display = 'none';
				table.style.display = 'none';
				return;
			}

			// Store the original data for sorting (only when we have new data from search)
			const isNewData = originalUserTableData.length === 0 || 
							  originalUserTableData.length !== users.length ||
							  (users.length > 0 && originalUserTableData.length > 0 && 
							   originalUserTableData[0]?.user_id !== users[0]?.user_id);
			
			if (isNewData) {
				originalUserTableData = [...users];
				console.log('Updated original table data with new search results');
			}

			// Sort users based on current sort state
			const sortedUsers = [...users].sort((a, b) => {
				let aVal = a[userTableSort.column];
				let bVal = b[userTableSort.column];

				// Handle special cases
				if (userTableSort.column === 'last_seen') {
					aVal = new Date(aVal).getTime();
					bVal = new Date(bVal).getTime();
				} else if (typeof aVal === 'string') {
					aVal = aVal.toLowerCase();
					bVal = bVal.toLowerCase();
				}

				if (userTableSort.direction === 'asc') {
					return aVal > bVal ? 1 : -1;
				} else {
					return aVal < bVal ? 1 : -1;
				}
			});

			// Add click handlers for sorting if not already added
			if (!table.dataset.sortHandlersAdded) {
				table.querySelectorAll('th').forEach(th => {
					const column = th.dataset.sort;
					if (!column) return;

					th.style.cursor = 'pointer';
					th.addEventListener('click', () => {
						// Update sort state
						if (userTableSort.column === column) {
							userTableSort.direction = userTableSort.direction === 'asc' ? 'desc' : 'asc';
						} else {
							userTableSort.column = column;
							userTableSort.direction = 'desc';
						}

						// Update UI
						table.querySelectorAll('th').forEach(header => {
							header.classList.remove('sort-asc', 'sort-desc');
						});
						th.classList.add(`sort-${userTableSort.direction}`);

						// Re-render table with ORIGINAL filtered data, not all data
						updateUserTable(originalUserTableData);
					});
				});
				table.dataset.sortHandlersAdded = 'true';
			}

			// Render sorted users
			sortedUsers.forEach(user => {
				const row = tbody.insertRow();
				row.innerHTML = `
					<td>${user.user_id}</td>
					<td><span class="platform-badge platform-${user.platform.toLowerCase()}">${user.platform}</span></td>
					<td>${user.device_model}</td>
					<td>
						<div><strong>${user.app_display_version || 'Unknown'}</strong></div>
						<small>(Build: ${user.app_build_version || 'N/A'})</small>
					</td>
					<td>${parseInt(user.errors).toLocaleString()} (${user.crash_instances} instances)</td>
					<td><span class="risk-badge ${getRiskBadgeClass(user.risk)}">${parseFloat(user.risk).toFixed(1)}</span></td>
					<td>${parseInt(user.last_24h).toLocaleString()}</td>
					<td>${user.source}</td>
					<td>
						<div><strong>Issue:</strong> ${user.crashlytics_issue_title}</div>
						<div><small><strong>Error Type:</strong> ${user.crashlytics_error_type}</small></div>
						<div><small><strong>Memory:</strong> ${(user.avg_memory_used_mb || 0).toFixed(1)}MB used / ${(user.avg_memory_free_mb || 0).toFixed(1)}MB free</small></div>
						${user.is_fatal ? '<span class="risk-badge risk-critical">Crash</span>' : '<span class="risk-badge risk-medium">Error</span>'}
						${user.has_correlated_errors ? '<span class="risk-badge risk-high">Correlated</span>' : ''}
					</td>
					<td>
						<div><strong>Latest Error:</strong> ${user.sentry_latest_error}</div>
						<div><small><strong>Total Errors:</strong> ${user.sentry_total_errors}</small></div>
						<div><small><strong>Unique Issues:</strong> ${user.sentry_unique_issues}</small></div>
						<button class="btn-secondary" style="padding: 2px 6px; font-size: 10px; margin-top: 2px;" 
							onclick='showSentryDetails(\`${user.top_sentry_errors_json}\`)'>
							Top Errors
						</button>
					</td>
					<td>
						<div><strong>Duration:</strong> ${user.error_duration_hours}h</div>
						<div><strong>Rate:</strong> ${user.errors_per_hour.toFixed(2)}/h</div>
						<div><strong>Last 24h:</strong> ${user.last_24h}</div>
						<div style="margin-top: 2px;">
							<span class="platform-badge platform-${user.platform.toLowerCase()}">${user.errors} total</span>
						</div>
					</td>
					<td>${new Date(user.last_seen).toLocaleString()}</td>
				`;
			});

			tableLoading.style.display = 'none';
			table.style.display = 'table';
		}

		function getRiskBadgeClass(score) {
			if (score >= 90) return 'risk-critical';
			if (score >= 75) return 'risk-high';
			if (score >= 50) return 'risk-medium';
			return 'risk-low';
		}

		function updateCharts(data) {
			console.log('Updating charts with data:', data);

			// Platform Distribution
			const platformCtx = document.getElementById('platformChart')?.getContext('2d');
			if (platformCtx) {
				if (charts.platform) {
					charts.platform.destroy();
				}
				charts.platform = new Chart(platformCtx, {
					type: 'doughnut',
					data: {
						labels: ['iOS', 'Android'],
						datasets: [{
							data: [data.iosUsers || 0, data.androidUsers || 0],
							backgroundColor: ['#000000', '#3ddc84']
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							legend: {
								position: 'bottom'
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										const total = data.iosUsers + data.androidUsers;
										const percentage = ((context.raw / total) * 100).toFixed(1);
										return `${context.label}: ${context.raw.toLocaleString()} (${percentage}%)`;
									}
								}
							}
						}
					}
				});
			}

			// Crash Trend Chart
			const crashTrendCtx = document.getElementById('crashTrendChart')?.getContext('2d');
			if (crashTrendCtx && data.dailyTrend && data.dailyTrend.length > 0) {
				// Group data by time bucket and platform
				const groupedData = data.dailyTrend.reduce((acc, curr) => {
					const timeBucket = curr.time_bucket;
					if (!acc[timeBucket]) {
						acc[timeBucket] = { IOS: 0, ANDROID: 0 };
					}
					acc[timeBucket][curr.platform] = curr.daily_crashes;
					return acc;
				}, {});

				// Get sorted time buckets
				const timeBuckets = Object.keys(groupedData).sort();

				// Prepare datasets
				const iosData = timeBuckets.map(time => groupedData[time].IOS || 0);
				const androidData = timeBuckets.map(time => groupedData[time].ANDROID || 0);

				// Format time buckets for display
				const formattedDates = timeBuckets.map(time => {
					const date = new Date(time);
					return document.getElementById('dateRange').value === 'hour'
						? date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })
						: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
				});

				if (charts.crashTrend) {
					charts.crashTrend.destroy();
				}

				charts.crashTrend = new Chart(crashTrendCtx, {
					type: 'line',
					data: {
						labels: formattedDates,
						datasets: [
							{
								label: 'iOS',
								data: iosData,
								borderColor: '#000000',
								backgroundColor: 'rgba(0, 0, 0, 0.1)',
								tension: 0.3,
								pointRadius: 4,
								pointHoverRadius: 6,
								fill: true
							},
							{
								label: 'Android',
								data: androidData,
								borderColor: '#3ddc84',
								backgroundColor: 'rgba(61, 220, 132, 0.1)',
								tension: 0.3,
								pointRadius: 4,
								pointHoverRadius: 6,
								fill: true
							}
						]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						interaction: {
							intersect: false,
							mode: 'index'
						},
						plugins: {
							legend: {
								position: 'bottom',
								labels: {
									usePointStyle: true,
									pointStyle: 'circle'
								}
							},
							tooltip: {
								callbacks: {
									title: function(context) {
										const date = new Date(timeBuckets[context[0].dataIndex]);
										if (document.getElementById('dateRange').value === 'hour') {
											return date.toLocaleString('en-US', {
												weekday: 'long',
												year: 'numeric',
												month: 'long',
												day: 'numeric',
												hour: 'numeric',
												minute: '2-digit'
											});
										} else {
											return date.toLocaleDateString('en-US', {
												weekday: 'long',
												year: 'numeric',
												month: 'long',
												day: 'numeric'
											});
										}
									},
									label: function(context) {
										const total = iosData[context.dataIndex] + androidData[context.dataIndex];
										const percentage = ((context.raw / total) * 100).toFixed(1);
										return `${context.dataset.label}: ${context.raw.toLocaleString()} crashes (${percentage}%)`;
									}
								}
							}
						},
						scales: {
							y: {
								stacked: true,
								beginAtZero: true,
								title: {
									display: true,
									text: 'Daily Crashes',
									font: {
										weight: 'bold'
									}
								},
								ticks: {
									callback: function(value) {
										return value.toLocaleString();
									}
								},
								grid: {
									color: 'rgba(0, 0, 0, 0.1)'
								}
							},
							x: {
								grid: {
									display: false
								}
							}
						}
					}
				});
			}

			// Device Chart
			const deviceCtx = document.getElementById('deviceChart')?.getContext('2d');
			if (deviceCtx && data.deviceStats && data.deviceStats.length > 0) {
				// Sort devices by crash count
				const sortedDevices = [...data.deviceStats]
					.sort((a, b) => b.crash_count - a.crash_count);

				const deviceLabels = sortedDevices.map(d => `${d.device_model} (${d.platform})`);
				const deviceData = sortedDevices.map(d => d.crash_count);
				const deviceColors = sortedDevices.map(d => d.platform === 'IOS' ? '#000000' : '#3ddc84');

				if (charts.device) {
					charts.device.destroy();
				}
				charts.device = new Chart(deviceCtx, {
					type: 'bar',
					data: {
						labels: deviceLabels,
						datasets: [{
							label: 'Crashes',
							data: deviceData,
							backgroundColor: deviceColors
						}]
					},
					options: {
						indexAxis: 'y',
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							legend: {
								display: false
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										const device = sortedDevices[context.dataIndex];
										return [
											`Crashes: ${device.crash_count.toLocaleString()}`,
											`Total Errors: ${device.total_errors.toLocaleString()}`,
											`Affected Users: ${device.affected_users.toLocaleString()}`,
											`Avg Risk Score: ${device.avg_risk_score.toFixed(1)}`
										];
									}
								}
							}
						},
						scales: {
							x: {
								beginAtZero: true,
								ticks: {
									callback: function(value) {
										return value.toLocaleString();
									}
								}
							}
						}
					}
				});
			}

			// Error Types Chart
			const errorCtx = document.getElementById('errorChart')?.getContext('2d');
			if (errorCtx && data.errorTypes && data.errorTypes.length > 0) {
				console.log('Rendering error types chart with data:', data.errorTypes);
				
				// Sort error types by count
				const sortedErrors = [...data.errorTypes]
					.sort((a, b) => b.error_count - a.error_count)
					.slice(0, 10); // Limit to top 10

				const errorLabels = sortedErrors.map(d => {
					const platform = d.platform ? ` (${d.platform})` : '';
					return `${d.error_type}${platform}`.length > 30 
						? `${d.error_type}${platform}`.substring(0, 27) + '...'
						: `${d.error_type}${platform}`;
				});
				const errorData = sortedErrors.map(d => d.error_count);
				const errorColors = sortedErrors.map(d => {
					if (d.platform === 'IOS') return '#000000';
					if (d.platform === 'ANDROID') return '#3ddc84';
					return 'rgba(118, 75, 162, 0.8)'; // Default color for mixed/unknown
				});

				if (charts.error) {
					charts.error.destroy();
				}
				charts.error = new Chart(errorCtx, {
					type: 'bar',
					data: {
						labels: errorLabels,
						datasets: [{
							label: 'Occurrences',
							data: errorData,
							backgroundColor: errorColors
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							legend: {
								display: false
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										const error = sortedErrors[context.dataIndex];
										const details = [
											`${error.error_count.toLocaleString()} occurrences`,
											`Platform: ${error.platform || 'Mixed'}`
										];
										if (error.error_details && error.error_details !== 'No details') {
											details.push('Details:');
											error.error_details.split(',').forEach(detail => {
												if (detail.trim()) details.push(`  ${detail.trim()}`);
											});
										}
										return details;
									}
								}
							}
						},
						scales: {
							y: {
								beginAtZero: true,
								title: {
									display: true,
									text: 'Number of Occurrences'
								},
								ticks: {
									callback: function(value) {
										return value.toLocaleString();
									}
								}
							},
							x: {
								ticks: {
									maxRotation: 45,
									minRotation: 45
								}
							}
						}
					}
				});
			} else {
				console.log('Error types chart not rendered. Data:', data.errorTypes);
			}

			// Fatality Distribution Chart
			const fatalityCtx = document.getElementById('fatalityChart')?.getContext('2d');
			if (fatalityCtx && data.fatalityStats && data.fatalityStats.length > 0) {
				const platforms = ['IOS', 'ANDROID'];
				const fatalData = [];
				const nonFatalData = [];

				platforms.forEach(platform => {
					const stats = data.fatalityStats.find(s => s.platform === platform) || { fatal_count: 0, non_fatal_count: 0 };
					fatalData.push(stats.fatal_count);
					nonFatalData.push(stats.non_fatal_count);
				});

				if (charts.fatality) {
					charts.fatality.destroy();
				}

				charts.fatality = new Chart(fatalityCtx, {
					type: 'bar',
					data: {
						labels: ['iOS', 'Android'],
						datasets: [
							{
								label: 'Crashes',
								data: fatalData,
								backgroundColor: '#ef4444',
								borderRadius: 4
							},
							{
								label: 'Errors',
								data: nonFatalData,
								backgroundColor: '#22c55e',
								borderRadius: 4
							}
						]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							legend: {
								position: 'bottom',
								labels: {
									usePointStyle: true,
									pointStyle: 'circle'
								}
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										const total = fatalData[context.dataIndex] + nonFatalData[context.dataIndex];
										const percentage = ((context.raw / total) * 100).toFixed(1);
										return `${context.dataset.label}: ${context.raw.toLocaleString()} (${percentage}%)`;
									}
								}
							}
						},
						scales: {
							x: {
								grid: {
									display: false
								}
							},
							y: {
								stacked: true,
								beginAtZero: true,
								title: {
									display: true,
									text: 'Number of Crashes',
									font: {
										weight: 'bold'
									}
								},
								ticks: {
									callback: function(value) {
										return value.toLocaleString();
									}
								},
								grid: {
									color: 'rgba(0, 0, 0, 0.1)'
								}
							}
						}
					}
				});
			}

			// App Version Breakdown Chart (Time Series)
			const appVersionCtx = document.getElementById('appVersionChart')?.getContext('2d');
			if (appVersionCtx && data.appVersionBreakdown && data.appVersionBreakdown.length > 0) {
				console.log('App version breakdown data:', data.appVersionBreakdown);
				
				// Group data by time_bucket and create datasets for each version
				const timeBuckets = [...new Set(data.appVersionBreakdown.map(v => v.time_bucket))].sort();
				const versions = [...new Set(data.appVersionBreakdown.map(v => v.app_display_version))];
				
				// Define colors for different versions
				const colors = [
					'#ef4444', '#3b82f6', '#22c55e', '#f59e0b', '#8b5cf6',
					'#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'
				];
				
				const datasets = versions.slice(0, 5).map((version, index) => {
					const versionData = timeBuckets.map(timeBucket => {
						const dataPoint = data.appVersionBreakdown.find(
							v => v.time_bucket === timeBucket && v.app_display_version === version
						);
						return dataPoint ? dataPoint.total_events : 0;
					});
					
					return {
						label: version,
						data: versionData,
						borderColor: colors[index % colors.length],
						backgroundColor: colors[index % colors.length] + '20',
						borderWidth: 2,
						fill: false,
						tension: 0.4
					};
				});

				if (charts.appVersion) {
					charts.appVersion.destroy();
				}

				charts.appVersion = new Chart(appVersionCtx, {
					type: 'line',
					data: {
						labels: timeBuckets.map(bucket => {
							// Format labels based on date range
							if (bucket.includes(':')) {
								// Hourly format
								return new Date(bucket).toLocaleString('en-US', { 
									month: 'short', day: 'numeric', hour: 'numeric' 
								});
							} else {
								// Daily format
								return new Date(bucket).toLocaleDateString('en-US', { 
									month: 'short', day: 'numeric' 
								});
							}
						}),
						datasets: datasets
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							legend: {
								position: 'bottom',
								labels: {
									usePointStyle: true,
									pointStyle: 'circle'
								}
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										const timeBucket = timeBuckets[context.dataIndex];
										const version = context.dataset.label;
										const dataPoint = data.appVersionBreakdown.find(
											v => v.time_bucket === timeBucket && v.app_display_version === version
										);
										
										if (dataPoint) {
											return [
												`${version}: ${context.parsed.y.toLocaleString()} events`,
												`Build: ${dataPoint.app_build_version}`,
												`Crashes: ${dataPoint.crashes}`,
												`Errors: ${dataPoint.errors}`,
												`Users: ${dataPoint.affected_users}`
											];
										}
										return `${version}: ${context.parsed.y.toLocaleString()} events`;
									}
								}
							}
						},
						scales: {
							x: {
								grid: {
									display: true,
									color: 'rgba(0, 0, 0, 0.1)'
								},
								title: {
									display: true,
									text: 'Time Period'
								}
							},
							y: {
								beginAtZero: true,
								title: {
									display: true,
									text: 'Number of Events',
									font: {
										weight: 'bold'
									}
								},
								ticks: {
									callback: function(value) {
										return value.toLocaleString();
									}
								},
								grid: {
									color: 'rgba(0, 0, 0, 0.1)'
								}
							}
						}
					}
				});
			} else {
				console.log('App version chart not rendered. Data:', data.appVersionBreakdown);
			}

			// Memory vs Crashes Chart
			const memoryCtx = document.getElementById('memoryChart')?.getContext('2d');
			if (memoryCtx && data.memoryBreakdown && data.memoryBreakdown.length > 0) {
				console.log('Memory breakdown data:', data.memoryBreakdown);
				
				// Get current crash type filter to determine what to show
				const crashTypeFilter = document.getElementById('crashTypeFilter').value;
				
				const memoryLabels = data.memoryBreakdown.map(m => m.memory_category);
				const crashData = data.memoryBreakdown.map(m => m.crashes || 0);
				const errorData = data.memoryBreakdown.map(m => m.errors || 0);
				
				// Calculate memory correlation analysis
				const totalCrashes = crashData.reduce((sum, crashes) => sum + crashes, 0);
				const criticalAndLowCrashes = data.memoryBreakdown
					.filter(m => m.memory_category.includes('Critical') || m.memory_category.includes('Low'))
					.reduce((sum, m) => sum + (m.crashes || 0), 0);
				const lowMemoryPercentage = totalCrashes > 0 ? ((criticalAndLowCrashes / totalCrashes) * 100).toFixed(1) : 0;
				
				// Define colors based on memory severity
				const backgroundColors = data.memoryBreakdown.map(m => {
					switch(m.memory_category) {
						case 'Critical (<50MB)': return '#dc2626'; // Red
						case 'Low (50-100MB)': return '#ea580c'; // Orange
						case 'Medium (100-200MB)': return '#d97706'; // Amber
						case 'Good (200-500MB)': return '#65a30d'; // Lime
						case 'Excellent (>500MB)': return '#16a34a'; // Green
						default: return '#6b7280'; // Gray
					}
				});

				// Build datasets based on filter
				let datasets = [];
				let chartTitle = 'Memory vs Events';
				
				if (crashTypeFilter === 'fatal') {
					// Show only crashes
					datasets = [{
						label: 'Crashes',
						data: crashData,
						backgroundColor: backgroundColors.map(color => color + '99'),
						borderColor: backgroundColors,
						borderWidth: 2,
						borderRadius: 4
					}];
					chartTitle = `Memory vs Crashes (${lowMemoryPercentage}% in Critical/Low Memory)`;
				} else if (crashTypeFilter === 'non-fatal') {
					// Show only errors
					datasets = [{
						label: 'Errors',
						data: errorData,
						backgroundColor: backgroundColors.map(color => color + '33'),
						borderColor: backgroundColors,
						borderWidth: 1,
						borderRadius: 4
					}];
					chartTitle = 'Memory vs Errors';
				} else {
					// Show both crashes and errors
					datasets = [
						{
							label: 'Crashes',
							data: crashData,
							backgroundColor: backgroundColors.map(color => color + '99'),
							borderColor: backgroundColors,
							borderWidth: 2,
							borderRadius: 4
						},
						{
							label: 'Errors',
							data: errorData,
							backgroundColor: backgroundColors.map(color => color + '33'),
							borderColor: backgroundColors,
							borderWidth: 1,
							borderRadius: 4
						}
					];
					chartTitle = `Memory vs Events (${lowMemoryPercentage}% crashes in Critical/Low Memory)`;
				}

				// Update chart title in HTML
				document.getElementById('memoryChartTitle').textContent = chartTitle;

				if (charts.memory) {
					charts.memory.destroy();
				}

				// For pie chart, we need to restructure the data
				let pieData = [];
				let pieColors = [];
				let pieLabels = [];
				
				if (crashTypeFilter === 'fatal') {
					// Show only crashes in pie chart
					data.memoryBreakdown.forEach((m, index) => {
						if (m.crashes > 0) {
							pieData.push(m.crashes);
							pieLabels.push(m.memory_category);
							pieColors.push(backgroundColors[index]);
						}
					});
				} else if (crashTypeFilter === 'non-fatal') {
					// Show only errors in pie chart
					data.memoryBreakdown.forEach((m, index) => {
						if (m.errors > 0) {
							pieData.push(m.errors);
							pieLabels.push(m.memory_category);
							pieColors.push(backgroundColors[index]);
						}
					});
				} else {
					// Show total events (crashes + errors) in pie chart
					data.memoryBreakdown.forEach((m, index) => {
						if (m.total_events > 0) {
							pieData.push(m.total_events);
							pieLabels.push(m.memory_category);
							pieColors.push(backgroundColors[index]);
						}
					});
				}

				charts.memory = new Chart(memoryCtx, {
					type: 'pie',
					data: {
						labels: pieLabels,
						datasets: [{
							data: pieData,
							backgroundColor: pieColors,
							borderColor: pieColors.map(color => color.replace(/[0-9a-f]{2}$/i, 'ff')), // Full opacity for borders
							borderWidth: 2,
							hoverOffset: 4
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							title: {
								display: true,
								text: chartTitle,
								font: {
									size: 16,
									weight: 'bold'
								},
								padding: 20
							},
							legend: {
								position: 'right',
								labels: {
									usePointStyle: true,
									pointStyle: 'circle',
									padding: 15,
									font: {
										size: 12
									}
								}
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										// Find the correct memory data based on the label
										const memory = data.memoryBreakdown.find(m => m.memory_category === context.label);
										const percentage = ((context.parsed / pieData.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
										
										let eventType = 'events';
										if (crashTypeFilter === 'fatal') {
											eventType = 'crashes';
										} else if (crashTypeFilter === 'non-fatal') {
											eventType = 'errors';
										}
										
										const details = [
											`${context.label}: ${context.parsed.toLocaleString()} ${eventType} (${percentage}%)`,
											`Affected Users: ${memory?.affected_users?.toLocaleString() || 'N/A'}`,
											`Avg Free Memory: ${memory?.avg_free_memory?.toFixed(1) || 'N/A'}MB`,
											`Range: ${memory?.min_free_memory?.toFixed(1) || 'N/A'}-${memory?.max_free_memory?.toFixed(1) || 'N/A'}MB`
										];
										
										// Add correlation info for crashes
										if (crashTypeFilter === 'fatal' || crashTypeFilter === '') {
											const memoryCategory = memory?.memory_category || '';
											if (memoryCategory.includes('Critical') || memoryCategory.includes('Low')) {
												details.push('‚ö†Ô∏è Low memory situation!');
											}
										}
										return details;
									}
								}
							}
						}
					}
				});
			} else {
				console.log('Memory chart not rendered. Data:', data.memoryBreakdown);
			}

			// Crash Names Breakdown Chart
			const crashNamesCtx = document.getElementById('crashNamesChart')?.getContext('2d');
			if (crashNamesCtx && data.crashNamesBreakdown && data.crashNamesBreakdown.length > 0) {
				console.log('Crash names breakdown data:', data.crashNamesBreakdown);
				
				// Get current crash type filter
				const crashTypeFilter = document.getElementById('crashTypeFilter').value;
				
				// Prepare data based on filter
				let chartData = [];
				let chartLabels = [];
				let chartColors = [];
				let chartTitle = '';
				
				if (crashTypeFilter === 'fatal') {
					// Show only crashes
					data.crashNamesBreakdown.forEach((crash, index) => {
						if (crash.crashes > 0) {
							chartData.push(crash.crashes);
							// Truncate long crash names for better display
							const truncatedName = crash.crash_name.length > 30 ? 
								crash.crash_name.substring(0, 30) + '...' : crash.crash_name;
							chartLabels.push(`${truncatedName} (${crash.platform})`);
							chartColors.push(`hsl(${(index * 137.5) % 360}, 70%, 60%)`); // Generate distinct colors
						}
					});
					chartTitle = `Top Crash Names (${chartData.length} different crashes)`;
				} else if (crashTypeFilter === 'non-fatal') {
					// Show only errors
					data.crashNamesBreakdown.forEach((crash, index) => {
						if (crash.errors > 0) {
							chartData.push(crash.errors);
							const truncatedName = crash.crash_name.length > 30 ? 
								crash.crash_name.substring(0, 30) + '...' : crash.crash_name;
							chartLabels.push(`${truncatedName} (${crash.platform})`);
							chartColors.push(`hsl(${(index * 137.5) % 360}, 70%, 60%)`);
						}
					});
					chartTitle = `Top Error Names (${chartData.length} different errors)`;
				} else {
					// Show total events
					data.crashNamesBreakdown.forEach((crash, index) => {
						if (crash.total_events > 0) {
							chartData.push(crash.total_events);
							const truncatedName = crash.crash_name.length > 30 ? 
								crash.crash_name.substring(0, 30) + '...' : crash.crash_name;
							chartLabels.push(`${truncatedName} (${crash.platform})`);
							chartColors.push(`hsl(${(index * 137.5) % 360}, 70%, 60%)`);
						}
					});
					chartTitle = `Top Event Names (${chartData.length} different issues)`;
				}

				if (charts.crashNames) {
					charts.crashNames.destroy();
				}

				charts.crashNames = new Chart(crashNamesCtx, {
					type: 'doughnut',
					data: {
						labels: chartLabels,
						datasets: [{
							data: chartData,
							backgroundColor: chartColors,
							borderColor: chartColors.map(color => color.replace('60%', '80%')), // Darker borders
							borderWidth: 2,
							hoverOffset: 6
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							title: {
								display: true,
								text: chartTitle,
								font: {
									size: 16,
									weight: 'bold'
								},
								padding: 20
							},
							legend: {
								position: 'right',
								labels: {
									usePointStyle: true,
									pointStyle: 'circle',
									padding: 8,
									font: {
										size: 10
									},
									maxWidth: 200
								}
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										const crash = data.crashNamesBreakdown.find(c => {
											const truncatedName = c.crash_name.length > 30 ? 
												c.crash_name.substring(0, 30) + '...' : c.crash_name;
											return context.label.includes(truncatedName);
										});
										
										const percentage = ((context.parsed / chartData.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
										
										let eventType = 'events';
										if (crashTypeFilter === 'fatal') {
											eventType = 'crashes';
										} else if (crashTypeFilter === 'non-fatal') {
											eventType = 'errors';
										}
										
										const details = [
											`${context.parsed.toLocaleString()} ${eventType} (${percentage}%)`,
											`Full Name: ${crash?.crash_name || 'Unknown'}`,
											`Platform: ${crash?.platform || 'Unknown'}`,
											`Affected Users: ${crash?.affected_users?.toLocaleString() || 'N/A'}`,
											`Avg Memory: ${crash?.avg_memory_free?.toFixed(1) || 'N/A'}MB`,
											`Risk Score: ${crash?.avg_risk_score?.toFixed(1) || 'N/A'}`
										];
										
										return details;
									}
								}
							}
						}
					}
				});
			} else {
				console.log('Crash names chart not rendered. Data:', data.crashNamesBreakdown);
			}
		}

		// Auto-refresh toggle
		document.getElementById('autoRefresh').addEventListener('change', (e) => {
			if (e.target.checked) {
				autoRefreshInterval = setInterval(refreshData, 5 * 60 * 1000);
				console.log('Auto-refresh enabled (5 minutes)');
			} else {
				clearInterval(autoRefreshInterval);
				autoRefreshInterval = null;
				console.log('Auto-refresh disabled');
			}
		});

		// Filter change handlers (no automatic refresh - user must click Search button)
		// All filter changes now require clicking the Search button to update results
		// This allows users to configure multiple filters before executing the query

		// Export table data to CSV
		async function exportTableToCsv() {
			try {
				// Show loading state
				const exportBtn = document.getElementById('exportCsv');
				exportBtn.disabled = true;
				exportBtn.textContent = '‚è≥ Exporting...';

				// Build query parameters using the same logic as the main search
				const platform = document.getElementById('platformFilter').value;
				const riskLevel = document.getElementById('riskFilter').value;
				const source = document.getElementById('sourceFilter').value;
				const crashType = document.getElementById('crashTypeFilter').value;

				// Build date filter based on selected range type (same as buildQuery function)
				let dateFilter;
				const dateRangeType = document.querySelector('input[name="dateRangeType"]:checked')?.value || 'relative';
				
				if (dateRangeType === 'absolute') {
					// Use absolute date range
					const dateFrom = document.getElementById('dateFrom').value;
					const dateTo = document.getElementById('dateTo').value;
					
					if (dateFrom && dateTo) {
						const formatDateForBigQuery = (dateOnly, isEndDate = false) => {
							if (!dateOnly) return null;
							return isEndDate ? `${dateOnly} 23:59:59` : `${dateOnly} 00:00:00`;
						};
						
						const formattedDateFrom = formatDateForBigQuery(dateFrom, false);
						const formattedDateTo = formatDateForBigQuery(dateTo, true);
						
						dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP('${formattedDateFrom}') 
									  AND TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) <= TIMESTAMP('${formattedDateTo}')`;
					} else {
						dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 DAY)`;
					}
				} else {
					// Use relative date range
					const dateRange = document.getElementById('dateRange').value;
					
					if (dateRange === 'custom_hours') {
						const customHours = document.getElementById('customHours').value || '12';
						dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL ${customHours} HOUR)`;
					} else if (dateRange === 'hour') {
						dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 HOUR)`;
					} else {
						dateFilter = `TIMESTAMP(COALESCE(crashlytics_last_occurrence, sentry_last_seen)) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL ${dateRange} DAY)`;
					}
				}

				// Build where conditions (including multi-select filters)
				let whereConditions = [];
				if (platform) whereConditions.push(`platform = '${platform}'`);
				if (riskLevel) whereConditions.push(`user_risk_score >= ${riskLevel}`);
				if (source) whereConditions.push(`data_source = '${source}'`);
				if (crashType === 'fatal') whereConditions.push('is_fatal = TRUE');
				if (crashType === 'non-fatal') whereConditions.push('is_fatal = FALSE');

				// Handle multi-select memory filters
				const memoryFilters = getMultiSelectValues('memoryOptions');
				if (memoryFilters.length > 0) {
					const memoryConditions = [];
					memoryFilters.forEach(filter => {
						switch(filter) {
							case 'critical':
								memoryConditions.push('avg_memory_free_mb < 50');
								break;
							case 'low':
								memoryConditions.push('(avg_memory_free_mb >= 50 AND avg_memory_free_mb < 100)');
								break;
							case 'medium':
								memoryConditions.push('(avg_memory_free_mb >= 100 AND avg_memory_free_mb < 200)');
								break;
							case 'good':
								memoryConditions.push('(avg_memory_free_mb >= 200 AND avg_memory_free_mb < 500)');
								break;
							case 'excellent':
								memoryConditions.push('avg_memory_free_mb >= 500');
								break;
						}
					});
					if (memoryConditions.length > 0) {
						whereConditions.push(`(${memoryConditions.join(' OR ')})`);
					}
				}

				// Handle multi-select app version filters
				const appVersionFilters = getMultiSelectValues('appVersionOptions');
				if (appVersionFilters.length > 0) {
					const versionConditions = appVersionFilters.map(displayVersion => 
						`app_display_version = '${displayVersion}'`
					);
					whereConditions.push(`(${versionConditions.join(' OR ')})`);
				}

				// Build export query
				const query = `
					WITH filtered_data AS (
						SELECT *
						FROM \`${CONFIG.PROJECT_ID}.${CONFIG.DATASET_ID}.crash_analytics_dashboard\`
						WHERE ${dateFilter}
						${whereConditions.length > 0 ? 'AND ' + whereConditions.join(' AND ') : ''}
					)
					SELECT 
						user_id,
						platform,
						user_email,
						user_username,
						user_name,
						country_code,
						city,
						region,
						device_model,
						app_display_version,
						app_build_version,
						os_display_version,
						crashlytics_issue_id,
						crashlytics_issue_title,
						crashlytics_error_type,
						is_fatal,
						crashlytics_event_count,
						FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S', crashlytics_first_occurrence) as crashlytics_first_occurrence,
						FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S', crashlytics_last_occurrence) as crashlytics_last_occurrence,
						avg_memory_used_mb,
						avg_memory_free_mb,
						sentry_total_errors,
						sentry_unique_issues,
						sentry_latest_error,
						FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S', sentry_first_seen) as sentry_first_seen,
						FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S', sentry_last_seen) as sentry_last_seen,
						total_error_count,
						data_source,
						has_correlated_errors,
						user_risk_score,
						error_percentile,
						error_count_rank,
						platform_error_percentile,
						platform_error_rank,
						error_duration_hours,
						errors_per_hour,
						top_sentry_errors_json
					FROM filtered_data
					WHERE user_risk_score >= 75
					ORDER BY user_risk_score DESC, total_error_count DESC
				`;

				// Execute query
				const result = await executeBigQuery(query);
				if (!result.rows || result.rows.length === 0) {
					throw new Error('No data to export');
				}

				// Convert to CSV
				const headers = result.schema.fields.map(f => f.name);
				const rows = result.rows.map(row => 
					row.f.map(field => {
						const value = field.v || '';
						// Quote strings containing commas
						return value.includes(',') ? `"${value}"` : value;
					})
				);

				// Create CSV content
				const csv = [
					headers.join(','),
					...rows.map(row => row.join(','))
				].join('\n');

				// Create download link
				const blob = new Blob([csv], { type: 'text/csv' });
				const url = window.URL.createObjectURL(blob);
				const a = document.createElement('a');
				const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
				a.href = url;
				a.download = `crash-analytics-export-${timestamp}.csv`;
				document.body.appendChild(a);
				a.click();
				window.URL.revokeObjectURL(url);
				document.body.removeChild(a);

				// Reset button
				exportBtn.textContent = 'üìä Export to CSV';
				exportBtn.disabled = false;

			} catch (error) {
				console.error('Export failed:', error);
				alert('Failed to export data: ' + error.message);
				document.getElementById('exportCsv').textContent = '‚ùå Export Failed';
				setTimeout(() => {
					document.getElementById('exportCsv').textContent = 'üìä Export to CSV';
					document.getElementById('exportCsv').disabled = false;
				}, 3000);
			}
		}

		// Function to show detailed Sentry error information
		function showSentryDetails(topSentryErrorsJson) {
			try {
				const topErrors = JSON.parse(topSentryErrorsJson);
				let message = 'Top Sentry Errors:\n\n';
				
				if (Array.isArray(topErrors) && topErrors.length > 0) {
					topErrors.forEach((error, index) => {
						message += `${index + 1}. ${error.error_title}\n`;
						message += `   Platform: ${error.error_platform}\n`;
						message += `   Count: ${error.count} occurrences\n\n`;
					});
				} else {
					message += 'No detailed Sentry errors available for this user.';
				}
				
				alert(message);
			} catch (e) {
				console.error('Error parsing Sentry details:', e);
				alert('Error parsing Sentry details. Raw data: ' + topSentryErrorsJson);
			}
		}

		// Initialize search button state on page load
		document.addEventListener('DOMContentLoaded', () => {
			updateSearchButtonState();
		});

		// Close modal when clicking outside or pressing Escape
		document.addEventListener('click', (e) => {
			const noResultsModal = document.getElementById('noResultsModal');
			if (e.target === noResultsModal) {
				closeNoResultsModal();
			}
		});

		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape') {
				const noResultsModal = document.getElementById('noResultsModal');
				if (noResultsModal.classList.contains('show')) {
					closeNoResultsModal();
				}
			}
		});

		// No-op: initialization happens via script onload callbacks (see bottom of page)
	</script>

	<!-- Load Google APIs and Google Identity Services -->
	<script>
		// Ensure global functions are defined before loading scripts
		window.gapiLoaded = gapiLoaded;
		window.gisLoaded = gisLoaded;
	</script>
	<script async defer src="https://apis.google.com/js/api.js" onload="window.gapiLoaded()"></script>
	<script async defer src="https://accounts.google.com/gsi/client" onload="window.gisLoaded()"></script>
</body>
</html>



